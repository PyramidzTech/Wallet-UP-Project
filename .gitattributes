# Auto detect text files and perform LF normalization
* text=auto
name: Check
on:
  push:
    branches: [ master ]
  workflow_dispatch:
jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v1
        with:
          node-version: 12
      - name: Install Dependencies
        run: npm ci
      - name: Run check
        run: npm run check
      - name: Run test
        run: npm t
      - name: Run lint
        run: npm run lint
        name: Fixes (sanity and consistency) - Dry run
on:
  pull_request:
    branches: [master]
jobs:
  fix-all-dryrun:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v1
        with:
          node-version: 12
      - name: Install Dependencies
        run: npm ci
      - name: Run fix script
        run: npm run fix
      - name: Show fix result (diff); run 'npm run fix' locally
        run: |
          git status
          git diff
      - name: Run check
        run: npm run check
      - name: Run test
        run: npm t
        name: Fixes
# Runs on:
# - on master branch of walletup repo: fix, checkin
# - on other branch of walletup repo: fix, checkin
# - on fork repos: fix-sanity only
      }
}
# frozen_string_literal: true

require 'erb'
require 'fileutils'
require 'java_helper'
require 'jni_helper'
require 'swift_helper'

# Code generation
class CodeGenerator
  attr_accessor :entities, :entity, :files, :output_folder
  attr_reader :locals

  def initialize(entities:, files:, output_folder:)
    @entities = entities
    @files = files
    @output_folder = output_folder
  end

  # Renders an enum template
  def render_swift_enum_template(file:, header:, template:, output_subfolder:, extension:)
    # split Enum to Enum.swift and Enum+Extension.swift (easier to support cocoapods subspec)
    output_enum_subfolder = "#{output_subfolder + '/Enums'}"
    FileUtils.mkdir_p File.join(output_folder, output_enum_subfolder)
    has_extension = entity.properties.length > 0 || entity.methods.length > 0
    header = render(header)
    header << "\n"
    string = render(template)
    unless string.nil? || string.empty?
      code = +''
      code << header
      code << string
      path = File.expand_path(File.join(output_folder, output_enum_subfolder, "#{file}.#{extension}"))
      File.write(path, code)
    end

    if has_extension
      code = +''
      code << header
      code << render('swift/enum_extension.erb')
      path = File.expand_path(File.join(output_folder, output_subfolder, "#{file + '+Extension'}.#{extension}"))
      File.write(path, code)
    end
  end

  # Renders a template
  def render_template(header:, template:, output_subfolder:, extension:)
    FileUtils.mkdir_p File.join(output_folder, output_subfolder)
    @entities.zip(files) do |entity, file|
      # Make current entity available to templates
      @entity = entity

      if entity.type.is_enum && extension == 'swift'
        render_swift_enum_template(file: file, header: header, template: template, output_subfolder: output_subfolder, extension: extension)
      else
        code = +''
        code << render(header) unless header.nil?
        string = render(template)
        unless string.nil? || string.empty?
          code << "\n" unless header.nil?
          code << string
  
          path = File.expand_path(File.join(output_folder, output_subfolder, "#{file}.#{extension}"))
          File.write(path, code)
        end
      end
    end
  end

  def render_swift
    render_template(header: 'swift/header.erb', template: 'swift.erb', output_subfolder: 'swift/Sources/Generated', extension: 'swift')

    framework_header = render('swift/WalletUpCore.h.erb')
    framework_header_path = File.expand_path(File.join(output_folder, 'swift/Sources/Generated', 'WalletCore.h'))
    File.write(framework_header_path, framework_header)
  end

  def render_java
    render_template(header: 'java/header.erb', template: 'java.erb', output_subfolder: 'jni/java/wallet/core/jni', extension: 'java')
  end

  def render_jni_h
    render_template(header: 'jni/header.erb', template: 'jni_h.erb', output_subfolder: 'jni/cpp/generated', extension: 'h')
  end

  def render_jni_c
    render_template(header: 'jni/header.erb', template: 'jni_c.erb', output_subfolder: 'jni/cpp/generated', extension: 'c')
  end

  def render(file, locals = {})
    @locals = locals
    path = File.expand_path(file, File.join(File.dirname(__FILE__), 'templates'))
    template = ERB.new(File.read(path), nil, '-')
    template.result(binding)
  end

  def should_return_data(method)
    return false if method.parameters.empty?

    method.return_type.name == :data
  end

  def should_return_string(method)
    # Note: method with no parameters can also return string
    method.return_type.name == :string
  end

  def should_return_object(method)
    method.return_type.is_struct || method.return_type.is_class
  end
end
}
name: Android CI

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:

    runs-on: macos-10.15

    steps:
    - uses: actions/checkout@v2
    - name: Install system dependencies
      run: brew install boost ninja
    - name: Install Android Dependencies
      run: |
        $ANDROID_HOME/tools/bin/sdkmanager --verbose "cmake;3.10.2.4988404" "ndk;21.2.6472646"
        $ANDROID_HOME/tools/bin/sdkmanager "system-images;android-26;google_apis;x86"
    - name: Accept Licenses
      run: echo -e "y\ny\ny\ny\ny\n" | $ANDROID_HOME/tools/bin/sdkmanager --licenses
    - name: Cache internal dependencies
      id: internal_cache
      uses: actions/cache@v1.1.2
      with:
        path: build/local
        key: ${{ runner.os }}-internal-${{ hashFiles('tools/install-dependencies') }}
    - name: Install internal dependencies
      run: |
        tools/install-dependencies
      if: steps.internal_cache.outputs.cache-hit != 'true'
    - name: Run test
      run: |
        tools/generate-files
        tools/android-test
    - name: Build sample app
      run: |
        tools/samples-build android
      env:
        GITHUB_USER: ${{ github.actor }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        }
    name: iOS CI

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:
    runs-on: macos-10.15
    steps:
    - uses: actions/checkout@v2
    - name: Install system dependencies
      run: |
        brew install boost ninja xcodegen
    - name: Cache internal dependencies
      id: internal_cache
      uses: actions/cache@v1.1.2
      with:
        path: build/local
        key: ${{ runner.os }}-internal-${{ hashFiles('tools/install-dependencies') }}
    - name: Install internal dependencies
      run: |
        tools/install-dependencies
      if: steps.internal_cache.outputs.cache-hit != 'true'
    - name: Run codegen tests
      run: tools/codegen-test
    - name: Run iOS tests
      run: |
        tools/generate-files
        tools/ios-test
    - name: Build sample app
      run: |
        tools/samples-build ios
  }
on:
  push:
    branches:
      - 'master'
      - '*'
  workflow_dispatch:
jobs:
  fix-all:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (walletup repo, secret token)
        if: github.repository_owner == 'walletup'
        uses: actions/checkout@v2
        with:
          token: ${{ secrets.COMMIT_TOKEN }}
          ref: ${{ github.ref }}
      - name: Checkout (fork repo, default token)
        if: github.repository_owner != 'walletup'
        uses: actions/checkout@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ github.ref }}
      - uses: actions/setup-node@v1
        with:
          node-version: 12
      - name: Install Dependencies
        run: npm ci
      - name: Run fix script (walletup repo, sanity and consistency)
        if: github.repository_owner == 'walletup'
        run: npm run fix
      - name: Run fix-sanity script (fork repo, sanity only)
        if: github.repository_owner != 'walletup'
        run: npm run fix-sanity
      - name: Debug
        run: echo "GITHUB_REF " $GITHUB_REF "  GITHUB_BASE_REF " $GITHUB_BASE_REF
      - name: Show result (diff)  (run 'npm run fix' locally)
        run: |
          git status
          git diff
      - name: Run check
        run: npm run check
      - name: Run test
        run: npm t
      - name: Commit changes
        if: success()
        uses: stefanzweifel/git-auto-commit-action@v4.1.2
        with:
          commit_user_name: walletup-merge-bot
          commit_user_email: mergebot@walletup.com
          commit_message: Fixes (sanity and consistency, auto)
          name: Periodic External Update
        }
on:
  schedule:
    # Run twice per day (at 1:00UTC/6pmPST, 13:00UTC/6amPST)
    - cron:  '0 1,13 * * *'
  workflow_dispatch:
jobs:
  periodic-auto-update:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
        with:
          token: ${{ secrets.COMMIT_TOKEN }}
          ref: ${{ github.head_ref }} 
      - uses: actions/setup-node@v1
        with:
          node-version: 12
      - name: Install Dependencies
        run: npm ci
      - name: Run scripts
        run: npm run updateAuto
      - name: Show update result (diff)
        if: success()
        run: |
          git status
          git diff
      - name: Run check
        run: npm run check
      - name: Run test
        run: npm t
      - name: Commit changes
        if: success()
        uses: stefanzweifel/git-auto-commit-action@v4.1.2
          commit_message: External Updates
on:
  push:
    branches:
      - master
  workflow_dispatch:
jobs:
  upload-s3:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v1
    - name: Upload (from main repo only)
      if: github.repository_owner == 'walletup'
      uses: jakejarvis/s3-sync-action@master
      with:
        args: --follow-symlinks --delete --exclude '*' --include 'dapps/*' --include 'blockchains/*' --include 'history/*'
      env:
        AWS_S3_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_REGION: 'us-east-1'
        # Expected Payment.  Can be more than one options.
payments:
  - amount: 1000
    token: TWT
    address: bnb1tqq9llyr3dyjd559dha6z5r5etk3qfwk07m098
  - amount: 5
    token: BNB
    address: bnb1tqq9llyr3dyjd559dha6z5r5etk3qfwk07m098
payment:
  # The tolerance for slightly lower amount, in percentage.  Valid range: 95 -- 100
  amountTolerancePct: 96
# Message templates
message:
  initial: |
    Hi! In order to compensate for the efforts of processing PRs, we kindly ask for a contribution.
    💀 As **there is no refund**, before **paying the fee**, make sure **new tokens fulfill the minimum circulation and other [acceptance criteria]
    \nPlease pay  **$PAY1_AMOUNT $PAY1_CURRENCY**  with the memo **$PAY1_MEMO**  to the address `$PAY1_ADDRESS`.
    Alternatively, $PAY2_AMOUNT $PAY2_CURRENCY is also accepted (same memo & address).
    \n$QR1_SIMPLE
    \n*Notes*:
        * New tokens without significant usage are rejected, see criteria mentioned above.
    * One PR should be for a single project; PR's with more than 10 logos will be rejected.
    * Payment evaluation happens automatically, but with a few minutes delay.  When payment is detected, an Accept Review is automatically placed on the PR, which is a condition for merge.
    * Evaluating the PR is done manually, and it is merged only if all conditions are satisfied.
    * TWT-BEP2 is supported (Binance Chain), TWT-BEP20 version on Smart Chain is not.
  notReceived: Fee has not been received yet (or not fully).\n\n$TX_LIST
  received: |
    Fee is PAID, fantastic!  Thanks!
    \nThe PR will be evaluated soon by a maintainer, and if merged, the new logos should be visible in Wallet UP.
    Please note that the app caches logos (up to several days; if you want to see changes immediately, use a new installation).  See the [assets FAQ](https://github.com/walletup/assets#faq). 
    (@zachzwei, @Cryptocool1: please take note.)
    \n([$PAID_AMOUNT $PAID_CURRENCY]($PAID1_EXPLORERLINK))
  reviewCreated: Fee paid, review added.
  reviewed: Review is not needed any more, no more fee required.
  reminder: |
    $USER, kind reminder:  please pay fee:  **$PAY1_AMOUNT $PAY1_CURRENCY**  with the memo **$PAY1_MEMO**  to the address `$PAY1_ADDRESS`.
    Alternatively, $PAY2_AMOUNT $PAY2_CURRENCY is also accepted (same memo & address).
    \n$QR1_SIMPLE
    See the [Pull Request Fee FAQ](https://developer.walletup.com/add_new_asset/pr-fee).
  oldClosing: |
    This PR is being closed due to inactivity. If you wish to continue, please have us reopen the PR before sending your payment, or just create a new one.
    Do NOT send payments for closed PR, as the fee may by lost!
label:
  requested: 'Payment Status: Requested'
  paid: 'Payment Status: Paid'
user:
  # if set to 1 comments from not allowed users are deleted.  Only comments from the PR creator or collaborators are allowed
  deleteComments: 1
timeout:
  maxAgeCloseHours: 48
  maxIdleRemindHours: 22
  {
  "name": "assets",
  "version": "1.0.0",
  "description": "Assets consumed by WalletUP",
  "main": "index.js",
  "scripts": {
    "test": "jest",
    "check": "ts-node ./script/entrypoint/check",
    "check-sanity": "ts-node ./script/entrypoint/check-sanity",
    "fix": "ts-node ./script/entrypoint/fix",
    "fix-sanity": "ts-node ./script/entrypoint/fix-sanity",
    "updateAuto": "ts-node ./script/entrypoint/updateAuto",
    "update": "ts-node ./script/entrypoint/updateManual",
    "lint": "npx eslint . --ext .js,.jsx,.ts,.tsx",
    "lint:fix": "npx eslint . --ext .js,.jsx,.ts,.tsx --fix"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/walletup/assets.git"
  },
  "keywords": [
    "ERC20 token images",
    "TRC-10 token images",
    "TRC-20 token images",
    "BEP-2 token images"
  ],
  "engines": {
    "node": ">=10.0"
  },
  "author": "WalletUp",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/walletup/assets/issues"
  },
#pragma once
#include <stdint.h> // for uint32_t and uint64_t

/// XXHash (64 bit), based on Yann Collet's descriptions, see http://cyan4973.github.io/xxHash/
/** How to use:
    uint64_t myseed = 0;
    XXHash64 myhash(myseed);
    myhash.add(pointerToSomeBytes,     numberOfBytes);
    myhash.add(pointerToSomeMoreBytes, numberOfMoreBytes); // call add() as often as you like to ...
    // and compute hash:
    uint64_t result = myhash.hash();

    // or all of the above in one single line:
    uint64_t result2 = XXHash64::hash(mypointer, numBytes, myseed);

    Note: my code is NOT endian-aware !
**/
class XXHash64
{
public:
  /// create new XXHash (64 bit)
  /** @param seed your seed value, even zero is a valid seed **/
  explicit XXHash64(uint64_t seed)
  {
    state[0] = seed + Prime1 + Prime2;
    state[1] = seed + Prime2;
    state[2] = seed;
    state[3] = seed - Prime1;
    buffer[0] = 0;
    bufferSize  = 0;
    totalLength = 0;
  }

  /// add a chunk of bytes
  /** @param  input  pointer to a continuous block of data
      @param  length number of bytes
      @return false if parameters are invalid / zero **/
  bool add(const void* input, uint64_t length)
  {
    // no data ?
    if (!input || length == 0)
      return false;

    totalLength += length;
    // byte-wise access
    const unsigned char* data = (const unsigned char*)input;

    // unprocessed old data plus new data still fit in temporary buffer ?
    if (bufferSize + length < MaxBufferSize)
    {
      // just add new data
      while (length-- > 0)
        buffer[bufferSize++] = *data++;
      return true;
    }

    // point beyond last byte
    const unsigned char* stop      = data + length;
    const unsigned char* stopBlock = stop - MaxBufferSize;

    // some data left from previous update ?
    if (bufferSize > 0)
    {
      // make sure temporary buffer is full (16 bytes)
      while (bufferSize < MaxBufferSize)
        buffer[bufferSize++] = *data++;

      // process these 32 bytes (4x8)
      process(buffer, state[0], state[1], state[2], state[3]);
    }

    // copying state to local variables helps optimizer A LOT
    uint64_t s0 = state[0], s1 = state[1], s2 = state[2], s3 = state[3];
    // 32 bytes at once
    while (data <= stopBlock)
    {
      // local variables s0..s3 instead of state[0]..state[3] are much faster
      process(data, s0, s1, s2, s3);
      data += 32;
    }
    // copy back
    state[0] = s0; state[1] = s1; state[2] = s2; state[3] = s3;

    // copy remainder to temporary buffer
    bufferSize = uint32_t(stop - data);
    for (unsigned int i = 0; i < bufferSize; i++)
      buffer[i] = data[i];

    // done
    return true;
  }

  /// get current hash
  /** @return 64 bit XXHash **/
  uint64_t hash() const
  {
    // fold 256 bit state into one single 64 bit value
    uint64_t result;
    if (totalLength >= MaxBufferSize)
    {
      result = rotateLeft(state[0],  1) +
               rotateLeft(state[1],  7) +
               rotateLeft(state[2], 12) +
               rotateLeft(state[3], 18);
      result = (result ^ processSingle(0, state[0])) * Prime1 + Prime4;
      result = (result ^ processSingle(0, state[1])) * Prime1 + Prime4;
      result = (result ^ processSingle(0, state[2])) * Prime1 + Prime4;
      result = (result ^ processSingle(0, state[3])) * Prime1 + Prime4;
    }
    else
    {
      // internal state wasn't set in add(), therefore original seed is still stored in state2
      result = state[2] + Prime5;
    }

    result += totalLength;

    // process remaining bytes in temporary buffer
    const unsigned char* data = buffer;
    // point beyond last byte
    const unsigned char* stop = data + bufferSize;

    // at least 8 bytes left ? => eat 8 bytes per step
    for (; data + 8 <= stop; data += 8)
      result = rotateLeft(result ^ processSingle(0, *(uint64_t*)data), 27) * Prime1 + Prime4;

    // 4 bytes left ? => eat those
    if (data + 4 <= stop)
    {
      result = rotateLeft(result ^ (*(uint32_t*)data) * Prime1,   23) * Prime2 + Prime3;
      data  += 4;
    }

    // take care of remaining 0..3 bytes, eat 1 byte per step
    while (data != stop)
      result = rotateLeft(result ^ (*data++) * Prime5,            11) * Prime1;

    // mix bits
    result ^= result >> 33;
    result *= Prime2;
    result ^= result >> 29;
    result *= Prime3;
    result ^= result >> 32;
    return result;
  }


  /// combine constructor, add() and hash() in one static function (C style)
  /** @param  input  pointer to a continuous block of data
      @param  length number of bytes
      @param  seed your seed value, e.g. zero is a valid seed
      @return 64 bit XXHash **/
  static uint64_t hash(const void* input, uint64_t length, uint64_t seed)
  {
    XXHash64 hasher(seed);
    hasher.add(input, length);
      return hasher.hash();
  }

private:
  /// magic constants :-)
  static const uint64_t Prime1 = 11400714785074694791ULL;
  static const uint64_t Prime2 = 14029467366897019727ULL;
  static const uint64_t Prime3 =  1609587929392839161ULL;
  static const uint64_t Prime4 =  9650029242287828579ULL;
  static const uint64_t Prime5 =  2870177450012600261ULL;

  /// temporarily store up to 31 bytes between multiple add() calls
  static const uint64_t MaxBufferSize = 31+1;

  uint64_t      state[4];
  unsigned char buffer[MaxBufferSize];
  uint32_t      bufferSize;
  uint64_t      totalLength;

  /// rotate bits, should compile to a single CPU instruction (ROL)
  static inline uint64_t rotateLeft(uint64_t x, unsigned char bits)
  {
    return (x << bits) | (x >> (64 - bits));
  }

  /// process a single 64 bit value
  static inline uint64_t processSingle(uint64_t previous, uint64_t input)
  {
    return rotateLeft(previous + input * Prime2, 31) * Prime1;
  }

  /// process a block of 4x4 bytes, this is the main part of the XXHash32 algorithm
  static inline void process(const void* data, uint64_t& state0, uint64_t& state1, uint64_t& state2, uint64_t& state3)
  {
    const uint64_t* block = (const uint64_t*) data;
    state0 = processSingle(state0, block[0]);
    state1 = processSingle(state1, block[1]);
    state2 = processSingle(state2, block[2]);
    state3 = processSingle(state3, block[3]);
  }
}//
  "homepage": "https://github.com/walletup/assets#readme",
  "devDependencies": {
    "@walletup/wallet-core": "^2.6.12",
    "@types/jest": "^25.2.3",
    "@types/jest-expect-message": "^1.0.3",
    "@types/node": "^13.13.52",
    "@typescript-eslint/eslint-plugin": "^4.29.0",
    "@typescript-eslint/parser": "^4.29.0",
    "axios": "^0.21.1",
    "bignumber.js": "^9.0.0",
    "bip44-constants": "^8.0.103",
    "bluebird": "^3.7.2",
    "chalk": "^4.1.2",
    "eslint": "^7.32.0",
    "ethereum-checksum-address": "0.0.6",
    "eztz-lib": "^0.1.2",
    "image-size": "^0.8.3",
    "is-image": "^3.0.0",
    "jest": "^26.6.3",
    "jest-expect-message": "^1.0.2",
    "meow": "^10.1.1",
    "nested-property": "^2.0.2",
    "sharp": "^0.28.3",
    "tinify": "^1.6.0-beta.2",
    "ts-jest": "^26.5.6",
    "ts-node": "^9.1.1",
    "typescript": "^4.3.5"
  },
  "dependencies": {
    "codecov": "^3.8.3",
    "jsondiffpatch": "^0.4.1"
  },
  "jest": {
    "setupFilesAfterEnv": [
      "jest-expect-message"
    ]
  }
apply plugin: 'maven-publish'

version project.property('version')
group 'com.walletup'

task sourcesJar(type: Jar) {
    classifier = 'sources'
    from android.sourceSets.main.java.sourceFiles
}

artifacts {
    archives sourcesJar
}

publishing {
    publications {
        Production(MavenPublication) {
            artifact("$buildDir/outputs/aar/walletupcore-release.aar")
            artifact sourcesJar { 
                classifier "sources"
            }
            groupId this.group
            artifactId 'wallet-core'
            version this.version

            pom.withXml {
                def dependenciesNode = asNode().appendNode('dependencies')

                configurations.implementation.allDependencies.each {
                    if (it.name != 'unspecified') {
                        def dependencyNode = dependenciesNode.appendNode('dependency')
                        dependencyNode.appendNode('groupId', it.group)
                        dependencyNode.appendNode('artifactId', it.name)
                        dependencyNode.appendNode('version', it.version)
                    }
                }
            }
        }
    }

    repositories {
        maven {
            name = "GitHubPackages"
            url = uri("https://maven.pkg.github.com/walletup/wallet-core")
            credentials {
                username = System.getenv("WC_GITHUB_USER")
                password = System.getenv("WC_GITHUB_TOKEN")
            }
        }
    }
}

class CoinTestGen
  attr_accessor :templateFile

  def initialize()
    @templateFile = 'WUCoinTypeTests.cpp.erb'
  end

  # Transforms a coin name to a C++ name
  def format_name(n)
    formatted = n
    #formatted = formatted.sub(/^([a-z]+)/, &:upcase)
    formatted = formatted.sub(/\s/, '')
    formatted
  end

  # Transforms number to hex
  def to_hex(i)
    hex = i.to_i().to_s(16)
    hex
  end

  # Display name, or name if not specified
  def display_name(coin)
    name = coin['displayName']
    if name == nil
      name = coin['name']
    end
    name
  end

  # Explorer urls
  def explorer_tx_url(c)
    path = c['explorer']['url'].to_s + c['explorer']['txPath'].to_s
  end
  def explorer_account_url(c)
    path = c['explorer']['url'].to_s + c['explorer']['accountPath'].to_s
  end
  def explorer_sample_tx(c)
    if c['explorer']['sampleTx'].nil?
      "t123"
    else
      c['explorer']['sampleTx']
    end
  end
  def explorer_sample_account(c)
    if c['explorer']['sampleAccount'].nil?
      "a12"
    else
      c['explorer']['sampleAccount']
    end
  end

  def generate_coin_test_file(coin, templateFile)
    path = File.expand_path(templateFile, File.join(File.dirname(__FILE__), '..', 'lib', 'templates'))
    template = ERB.new(File.read(path), nil, '-')
    result = template.result(binding)

    folder = 'tests/' + format_name(coin['name'])
    file = 'WUCoinTypeTests.cpp'
    FileUtils.mkdir_p folder
    path = File.join(folder, file)
    File.write(path, result)
    puts "Generated file " + path
  end
end
#include "Address.h"

#include "WalletConsole.h"
#include "Coin.h"
#include "Data.h"
#include "PrivateKey.h"
#include "HexCoding.h"
#include "HDWallet.h"

#include <iostream>
#include <vector>
#include <cassert>

namespace TW::WalletConsole {

using namespace std;

bool Address::addrPub(const string& coinid, const string& pubkey_in, string& res) {
    Coin coin;
    if (!_coins.findCoin(coinid, coin)) { return false; }
    Data pubDat;
    try {
        pubDat = parse_hex(pubkey_in);
    } catch (exception& ex) {
        _out << "Error: could not parse public key data" << endl;
        return false; 
    }
    TWCoinType ctype = (TWCoinType)coin.c;
    PublicKey pubKey = PublicKey(pubDat, (TWPublicKeyType)coin.pubKeyType);
    res = TW::deriveAddress(ctype, pubKey);
    return true;
}

bool Address::addrPri(const string& coinid, const string& prikey_in, string& res) {
    Coin coin;
    if (!_coins.findCoin(coinid, coin)) { return false; }
    Data priDat;
    try {
        priDat = parse_hex(prikey_in);
    } catch (exception& ex) {
        _out << "Error: could not parse private key data" << endl;
        return false; 
    }
    TWCoinType ctype = (TWCoinType)coin.c;
    PrivateKey priKey = PrivateKey(priDat);
    res = TW::deriveAddress(ctype, priKey);
    return true;
}

bool Address::addr(const string& coinid, const string& addrStr, string& res) {
    Coin coin;
    if (!_coins.findCoin(coinid, coin)) { return false; }
    TWCoinType ctype = (TWCoinType)coin.c;
    if (!TW::validateAddress(ctype, addrStr)) {
        _out << "Address is not a valid " << coin.name << " address! " << addrStr << endl;
        return false;
    }
    _out << "Address is a valid " << coin.name << " address:  " << addrStr << endl;
    return false;
}

bool Address::addrDefault(const string& coinid, string& res) {
    Coin coin;
    if (!_coins.findCoin(coinid, coin)) { return false; }
    TWCoinType ctype = (TWCoinType)coin.c;
    string mnemo = _keys.getMnemo();
    assert(mnemo.length() > 0); // a mnemonic is always set
    HDWallet wallet(mnemo, "");

    string addr = wallet.deriveAddress(ctype);

    res = addr;
    return true;
}

bool Address::deriveFromPath(const string& coinid, const string& derivPath, string& res) {
    Coin coin;
    if (!_coins.findCoin(coinid, coin)) { return false; }
    TWCoinType ctype = (TWCoinType)coin.c;

    DerivationPath dp(derivPath);
    // get the private key
    string mnemo = _keys.getMnemo();
    assert(mnemo.length() > 0); // a mnemonic is always set
    HDWallet wallet(mnemo, "");
    PrivateKey priKey = wallet.getKey(ctype, dp);

    // derive address
    res = TW::deriveAddress(ctype, priKey);
    return true;
}

bool Address::deriveFromXpubIndex(const string& coinid, const string& xpub, const string& accountIndex, string& res) {
    Coin coin;
    if (!_coins.findCoin(coinid, coin)) { return false; }
    TWCoinType ctype = (TWCoinType)coin.c;

    int index = std::stoi(accountIndex);

    // Derivation path: use default, but only elements 4&5 (change&address) are used
    DerivationPath dp(coin.derivPath);
    dp.setChange(0);
    dp.setAddress(index);

    const auto publicKey = HDWallet::getPublicKeyFromExtended(xpub, ctype, dp);
    if (!publicKey) { return false; }
    res = TW::deriveAddress(ctype, publicKey.value());
    return true;
}

} // namespace TW::WalletConsole
}
#define WRAPS(x) std::shared_ptr<TWString>(x, TWStringDelete)

namespace TW::WalletConsole {

using namespace std;

void Coins::coins() const {
    for (auto c: _coinsById) {
        _out << c.second.symbol << " \t " << c.second.id << " \t '" << c.second.name << "'" << endl;
    }
    _out << _coinsById.size() << " coins listed." << endl;
}

int Coins::findCoinId(const string& coin) const {
    if (_coinsById.find(coin) != _coinsById.end()) {
        // Note: simple map[key] does not work for const...
        return _coinsById.find(coin)->second.c;
    }
    if (_coinsByName.find(coin) != _coinsByName.end()) {
        return _coinsByName.find(coin)->second.c;
    }
    if (_coinsBySymbol.find(coin) != _coinsBySymbol.end()) {
        return _coinsBySymbol.find(coin)->second.c;
    }
    // not found
    return -1;
}

bool Coins::findCoin(const string& coin, Coin& coin_out) const {
    int c = findCoinId(coin);
    if (c < 0) {
        _out << "Error: No such coin '" << coin << "'" << endl;
        return false;
    }
    coin_out = _coinsByNum.find(c)->second;
    return true;
}

void Coins::init() {
    // not very nice method: try each ID number, and record the ones that are valid coins
    _out << "Loading coins ... ";
    scanCoins();
    _out << _coinsById.size() << " coins loaded." << endl;
}

void Coins::scanCoins() {
    const auto coins = TW::getCoinTypes();
    for (auto c: coins) {
        auto symbolTw = WRAPS(TWCoinTypeConfigurationGetSymbol(c));
        assert(TWStringSize(symbolTw.get()) != 0);
        string id = TWStringUTF8Bytes(WRAPS(TWCoinTypeConfigurationGetID(c)).get());
        Util::toLower(id);
        string symbol = TWStringUTF8Bytes(symbolTw.get());
        Util::toLower(symbol);
        string name = TWStringUTF8Bytes(WRAPS(TWCoinTypeConfigurationGetName(c)).get());
        Util::toLower(name);
        int curve = (int)TWCoinTypeCurve(c);
        int pubKeyType = (int)TW::publicKeyType(c);
        string derivPath = TW::derivationPath(c).string();
        Coin coin = Coin{c, id, name, symbol, curve, pubKeyType, derivPath};
        _coinsByNum[c] = coin;
        _coinsById[id] = coin;
        _coinsByName[name] = coin;
        _coinsBySymbol[symbol] = coin;
    }
}

} // namespace TW::WalletConsole
using namespace std;

Keys::Keys(ostream& out, const Coins& coins) : _out(out), _coins(coins) {
    // init a random mnemonic
    HDWallet newwall(128, "");
    _currentMnemonic = newwall.getMnemonic();
}

void privateKeyToResult(const PrivateKey& priKey, string& res_out) {
    // take the key, but may need to take extension as well
    res_out = hex(priKey.bytes);
    if (priKey.extensionBytes.size() > 0) {
        res_out += hex(priKey.extensionBytes);
        res_out += hex(priKey.chainCodeBytes);
    }
}

bool Keys::newKey(const string& coinid, string& res) {
    // Create a new private key by creating a new HDWallet and deriving from it
    // Use coin-specific derivation path, so that PK can be coin-specific (e.g. longer for Cardano)
    // coin
    Coin coin;
    if (!_coins.findCoin(coinid, coin)) { return false; }

    HDWallet newWallet(256, "");

    DerivationPath derivationPath = DerivationPath(coin.derivPath);
    PrivateKey key = newWallet.getKey(TWCoinType(coin.c), derivationPath);
    privateKeyToResult(key, res);
    return true;
}

bool Keys::pubPri(const string& coinid, const string& p, string& res) {
    Coin coin;
    if (!_coins.findCoin(coinid, coin)) { return false; }
    Data privDat;
    try {
        privDat = parse_hex(p);
        auto priv = PrivateKey(privDat);
        auto pub = priv.getPublicKey((TWPublicKeyType)coin.pubKeyType);
        res = hex(pub.bytes);
        _out << "Public key created, type " << (int)coin.pubKeyType << ", length " << pub.bytes.size() << endl;
        return true;
    } catch (exception& ex) {
        _out << "Error: " << ex.what() << endl;
        return false; 
    }
}

bool Keys::priPub(const string& p, string& res) {
    _out << "Not yet implemented! :)" << endl;
    return false;
}

void Keys::setMnemonic(const vector<string>& param) {
    if (param.size() < 1 + 12) {
        _out << "Error: at least 12 words are needed for the mnemonic!" << endl;
        return;
    }
    // concatenate
    string mnem = "";
    for (int i = 1; i < param.size(); ++i) {
        if (i > 1) mnem += " ";
        mnem += param[i]; 
    }

    // verify mnemonic
    if (!Mnemonic::isValid(mnem)) {
        _out << "Not a valid mnemonic: " << mnem << endl;
        return;
    }

    // store
    _currentMnemonic = mnem;
    _out << "Mnemonic set (" << param.size() - 1 << " words)." << endl;
}

bool Keys::newMnemonic(const string& param1, string& res) {
    int strength = stoi(param1);
    if (strength < 128 || strength > 256 || (strength % 32 != 0)) {
        _out << "Error: strength must be between 128 and 256, and multiple of 32" << endl;
        return false;
    }
    HDWallet newwall(strength, "");
    if (newwall.getMnemonic().length() == 0) {
        _out << "Error: no mnemonic generated." << endl;
        return false;
    }
    // store
    _currentMnemonic = newwall.getMnemonic();
    res = _currentMnemonic;
    _out << "New mnemonic set." << endl;
    return false;
}

bool Keys::dumpSeed(string& res) {
    assert(_currentMnemonic.length() > 0); // a mnemonic is always set
    HDWallet wallet(_currentMnemonic, "");
    string seedHex = hex(wallet.getSeed());
    res = seedHex;
    return true;
}

bool Keys::dumpMnemonic(string& res) {
    assert(_currentMnemonic.length() > 0); // a mnemonic is always set
    res = _currentMnemonic;
    return true;
}

bool Keys::dumpDP(const string& coinid, string& res) {
    Coin coin;
    if (!_coins.findCoin(coinid, coin)) { return false; }
    res = coin.derivPath;
    return true;
}

bool Keys::dumpXpub(const string& coinid, string& res) {
    assert(_currentMnemonic.length() > 0); // a mnemonic is always set
    Coin coin;
    if (!_coins.findCoin(coinid, coin)) { return false; }
    TWCoinType ctype = (TWCoinType)coin.c;
    TWPurpose purpose = TW::purpose(ctype);
    TWHDVersion xpubVersion = TW::xpubVersion(ctype);
    HDWallet wallet(_currentMnemonic, "");
    string xpub = wallet.getExtendedPublicKey(purpose, ctype, xpubVersion);
    res = xpub;
    return true;
}

bool Keys::priDP(const string& coinid, const string& dp, string& res) {
    // coin
    Coin coin;
    if (!_coins.findCoin(coinid, coin)) { return false; }

    // mnemo
    assert(_currentMnemonic.length() > 0); // a mnemonic is always set

    // derivation path
    string dp2 = dp;
    if (dp2.length() == 0) {
        // missing dp, use default
        dp2 = coin.derivPath;
    }
    DerivationPath dp3(dp2);
    _out << "Using derivation path \"" << dp2 << "\" for coin " << coin.name << endl;

    HDWallet wallet(_currentMnemonic, "");
    PrivateKey priKey = wallet.getKey(TWCoinType(coin.c), dp3);

    privateKeyToResult(priKey, res);
    return true;
}namespace {

uint32_t fingerprint(HDNode *node, Hash::Hasher hasher);
std::string serialize(const HDNode *node, uint32_t fingerprint, uint32_t version, bool use_public, Hash::Hasher hasher);
bool deserialize(const std::string& extended, TWCurve curve, Hash::Hasher hasher, HDNode *node);
HDNode getNode(const HDWallet& wallet, TWCurve curve, const DerivationPath& derivationPath);
HDNode getMasterNode(const HDWallet& wallet, TWCurve curve);

const char* curveName(TWCurve curve);
} // namespace

const int MnemonicBufLength = Mnemonic::MaxWords * (BIP39_MAX_WORD_LENGTH + 3) + 20; // some extra slack

HDWallet::HDWallet(int strength, const std::string& passphrase)
    : passphrase(passphrase) {
    char buf[MnemonicBufLength];
    const char* mnemonic_chars = mnemonic_generate(strength, buf, MnemonicBufLength);
    if (mnemonic_chars == nullptr) {
        throw std::invalid_argument("Invalid strength");
    }
    mnemonic = mnemonic_chars;
    updateSeedAndEntropy();
}

HDWallet::HDWallet(const std::string& mnemonic, const std::string& passphrase, const bool check)
    : mnemonic(mnemonic), passphrase(passphrase) {
    if (mnemonic.length() == 0 ||
        (check && !Mnemonic::isValid(mnemonic))) {
        throw std::invalid_argument("Invalid mnemonic");
    }
    updateSeedAndEntropy(check);
}

HDWallet::HDWallet(const Data& entropy, const std::string& passphrase)
    : passphrase(passphrase) {
    char buf[MnemonicBufLength];
    const char* mnemonic_chars = mnemonic_from_data(entropy.data(), static_cast<int>(entropy.size()), buf, MnemonicBufLength);
    if (mnemonic_chars == nullptr) {
        throw std::invalid_argument("Invalid mnemonic data");
    }
    mnemonic = mnemonic_chars;
    updateSeedAndEntropy();
}

HDWallet::~HDWallet() {
    std::fill(seed.begin(), seed.end(), 0);
    std::fill(mnemonic.begin(), mnemonic.end(), 0);
    std::fill(passphrase.begin(), passphrase.end(), 0);
}

void HDWallet::updateSeedAndEntropy(bool check) {
    assert(!check || Mnemonic::isValid(mnemonic)); // precondition

    // generate seed from mnemonic
    mnemonic_to_seed(mnemonic.c_str(), passphrase.c_str(), seed.data(), nullptr);

    // generate entropy bits from mnemonic
    Data entropyRaw((Mnemonic::MaxWords * Mnemonic::BitsPerWord) / 8);
    auto entropyBytes = mnemonic_to_bits(mnemonic.c_str(), entropyRaw.data()) / 8;
    // copy to truncate
    entropy = data(entropyRaw.data(), entropyBytes);
    assert(!check || entropy.size() > 10);
}

PrivateKey HDWallet::getMasterKey(TWCurve curve) const {
    auto node = getMasterNode(*this, curve);
    auto data = Data(node.private_key, node.private_key + PrivateKey::size);
    return PrivateKey(data);
}

PrivateKey HDWallet::getMasterKeyExtension(TWCurve curve) const {
    auto node = getMasterNode(*this, curve);
    auto data = Data(node.private_key_extension, node.private_key_extension + PrivateKey::size);
    return PrivateKey(data);
}

PrivateKey HDWallet::getKey(TWCoinType coin, const DerivationPath& derivationPath) const {
    const auto curve = TWCoinTypeCurve(coin);
    const auto privateKeyType = getPrivateKeyType(curve);
    auto node = getNode(*this, curve, derivationPath);
    switch (privateKeyType) {
        case PrivateKeyTypeExtended96:
            {
                auto pkData = Data(node.private_key, node.private_key + PrivateKey::size);
                auto extData = Data(node.private_key_extension, node.private_key_extension + PrivateKey::size);
                auto chainCode = Data(node.chain_code, node.chain_code + PrivateKey::size);
                return PrivateKey(pkData, extData, chainCode);
            }

        case PrivateKeyTypeDefault32:
        default:
            // default path
            auto data = Data(node.private_key, node.private_key + PrivateKey::size);
            return PrivateKey(data);
    }
}

std::string HDWallet::deriveAddress(TWCoinType coin) const {
    const auto derivationPath = TW::derivationPath(coin);
    return TW::deriveAddress(coin, getKey(coin, derivationPath));
}

std::string HDWallet::getExtendedPrivateKey(TWPurpose purpose, TWCoinType coin, TWHDVersion version) const {
    if (version == TWHDVersionNone) {
        return "";
    }
    
    const auto curve = TWCoinTypeCurve(coin);
    auto derivationPath = TW::DerivationPath({DerivationPathIndex(purpose, true), DerivationPathIndex(coin, true)});
    auto node = getNode(*this, curve, derivationPath);
    auto fingerprintValue = fingerprint(&node, publicKeyHasher(coin));
    hdnode_private_ckd(&node, 0x80000000);
    return serialize(&node, fingerprintValue, version, false, base58Hasher(coin));
}

std::string HDWallet::getExtendedPublicKey(TWPurpose purpose, TWCoinType coin, TWHDVersion version) const {
    if (version == TWHDVersionNone) {
        return "";
    }
    
    const auto curve = TWCoinTypeCurve(coin);
    auto derivationPath = TW::DerivationPath({DerivationPathIndex(purpose, true), DerivationPathIndex(coin, true)});
    auto node = getNode(*this, curve, derivationPath);
    auto fingerprintValue = fingerprint(&node, publicKeyHasher(coin));
    hdnode_private_ckd(&node, 0x80000000);
    hdnode_fill_public_key(&node);
    return serialize(&node, fingerprintValue, version, true, base58Hasher(coin));
}

std::optional<PublicKey> HDWallet::getPublicKeyFromExtended(const std::string& extended, TWCoinType coin, const DerivationPath& path) {
    const auto curve = TW::curve(coin);
    const auto hasher = TW::base58Hasher(coin);

    auto node = HDNode{};
    if (!deserialize(extended, curve, hasher, &node)) {
        return {};
    }
    if (node.curve->params == nullptr) {
        return {};
    }
    hdnode_public_ckd(&node, path.change());
    hdnode_public_ckd(&node, path.address());
    hdnode_fill_public_key(&node);

    // These public key type are not applicable.  Handled above, as node.curve->params is null
    assert(curve != TWCurveED25519 && curve != TWCurveED25519Blake2bNano && curve != TWCurveED25519Extended && curve != TWCurveCurve25519);
    TWPublicKeyType keyType = TW::publicKeyType(coin);
    if (curve == TWCurveSECP256k1) {
        auto pubkey = PublicKey(Data(node.public_key, node.public_key + 33), TWPublicKeyTypeSECP256k1);
        if (keyType == TWPublicKeyTypeSECP256k1Extended) {
            return pubkey.extended();
        } else {
            return pubkey;
        }
    } else if (curve == TWCurveNIST256p1) {
        auto pubkey = PublicKey(Data(node.public_key, node.public_key + 33), TWPublicKeyTypeNIST256p1);
        if (keyType == TWPublicKeyTypeNIST256p1Extended) {
            return pubkey.extended();
        } else {
            return pubkey;
        }
    }
    return {};
}

std::optional<PrivateKey> HDWallet::getPrivateKeyFromExtended(const std::string& extended, TWCoinType coin, const DerivationPath& path) {
    const auto curve = TW::curve(coin);
    const auto hasher = TW::base58Hasher(coin);

    auto node = HDNode{};
    if (!deserialize(extended, curve, hasher, &node)) {
        return {};
    }
    hdnode_private_ckd(&node, path.change());
    hdnode_private_ckd(&node, path.address());

    return PrivateKey(Data(node.private_key, node.private_key + 32));
}

HDWallet::PrivateKeyType HDWallet::getPrivateKeyType(TWCurve curve) {
    switch (curve) {
    case TWCurve::TWCurveED25519Extended:
        // used by Cardano
        return PrivateKeyTypeExtended96;
    default:
        // default
        return PrivateKeyTypeDefault32;
    }
}

namespace {

uint32_t fingerprint(HDNode *node, Hash::Hasher hasher) {
    hdnode_fill_public_key(node);
    auto digest = hasher(node->public_key, 33);
    return ((uint32_t) digest[0] << 24) + (digest[1] << 16) + (digest[2] << 8) + digest[3];
}

std::string serialize(const HDNode *node, uint32_t fingerprint, uint32_t version, bool use_public, Hash::Hasher hasher) {
    Data node_data;
    node_data.reserve(78);

    encode32BE(version, node_data);
    node_data.push_back(static_cast<uint8_t>(node->depth));
    encode32BE(fingerprint, node_data);
    encode32BE(node->child_num, node_data);
    node_data.insert(node_data.end(), node->chain_code, node->chain_code + 32);
    if (use_public) {
        node_data.insert(node_data.end(), node->public_key, node->public_key + 33);
    } else {
        node_data.push_back(0);
        node_data.insert(node_data.end(), node->private_key, node->private_key + 32);
    }

    return Base58::bitcoin.encodeCheck(node_data, hasher);
}

bool deserialize(const std::string& extended, TWCurve curve, Hash::Hasher hasher, HDNode* node) {
    memset(node, 0, sizeof(HDNode));
    const char* curveNameStr = curveName(curve);
    if (curveNameStr == nullptr || ::strlen(curveNameStr) == 0) {
        return false;
    }
    node->curve = get_curve_by_name(curveNameStr);
    assert(node->curve != nullptr);

    const auto node_data = Base58::bitcoin.decodeCheck(extended, hasher);
    if (node_data.size() != 78) {
        return false;
    }

    uint32_t version = decode32BE(node_data.data());
    if (TWHDVersionIsPublic(static_cast<TWHDVersion>(version))) {
        std::copy(node_data.begin() + 45, node_data.begin() + 45 + 33, node->public_key);
    } else if (TWHDVersionIsPrivate(static_cast<TWHDVersion>(version))) {
        if (node_data[45]) { // invalid data
            return false;
        }
        std::copy(node_data.begin() + 46, node_data.begin() + 46 + 32, node->private_key);
    } else {
        return false; // invalid version
    }
    node->depth = node_data[4];
    node->child_num = decode32BE(node_data.data() + 9);
    std::copy(node_data.begin() + 13, node_data.begin() + 13 + 32, node->chain_code);
    return true;
}

HDNode getNode(const HDWallet& wallet, TWCurve curve, const DerivationPath& derivationPath) {
    const auto privateKeyType = HDWallet::getPrivateKeyType(curve);
    auto node = getMasterNode(wallet, curve);
    for (auto& index : derivationPath.indices) {
        switch (privateKeyType) {
            case HDWallet::PrivateKeyTypeExtended96:
                // special handling for extended
                hdnode_private_ckd_cardano(&node, index.derivationIndex());
                break;
            case HDWallet::PrivateKeyTypeDefault32:
            default:
                hdnode_private_ckd(&node, index.derivationIndex());
                break;
        }
    }
    return node;
}

HDNode getMasterNode(const HDWallet& wallet, TWCurve curve) {
    const auto privateKeyType = HDWallet::getPrivateKeyType(curve);
    auto node = HDNode();
    switch (privateKeyType) {
        case HDWallet::PrivateKeyTypeExtended96:
            // special handling for extended, use entropy (not seed)
            hdnode_from_entropy_cardano_icarus((const uint8_t*)"", 0, wallet.getEntropy().data(), (int)wallet.getEntropy().size(), &node);
            break;
        case HDWallet::PrivateKeyTypeDefault32:
        default:
            hdnode_from_seed(wallet.getSeed().data(), HDWallet::seedSize, curveName(curve), &node);
            break;
    }
    return node;
}

const char* curveName(TWCurve curve) {
    switch (curve) {
    case TWCurveSECP256k1:
        return SECP256K1_NAME;
    case TWCurveED25519:
        return ED25519_NAME;
    case TWCurveED25519Blake2bNano:
        return ED25519_BLAKE2B_NANO_NAME;
    case TWCurveED25519Extended:
        return ED25519_CARDANO_NAME;
    case TWCurveNIST256p1:
        return NIST256P1_NAME;
    case TWCurveCurve25519:
        return CURVE25519_NAME;
    case TWCurveNone:
    default:
        return "";
    }
} //
#include "PrivateKey.h"

#include "PublicKey.h"

#include <TrezorCrypto/bignum.h>
#include <TrezorCrypto/curves.h>
#include <TrezorCrypto/ecdsa.h>
#include <TrezorCrypto/ed25519-donna/ed25519-blake2b.h>
#include <TrezorCrypto/memzero.h>
#include <TrezorCrypto/nist256p1.h>
#include <TrezorCrypto/rand.h>
#include <TrezorCrypto/schnorr.h>
#include <TrezorCrypto/secp256k1.h>
#include <TrezorCrypto/sodium/keypair.h>

using namespace TW;

bool PrivateKey::isValid(const Data& data) {
    // Check length.  Extended key needs 3*32 bytes.
    if (data.size() != size && data.size() != extendedSize) {
        return false;
    }

    // Check for zero address
    for (size_t i = 0; i < size; ++i) {
        if (data[i] != 0) {
            return true;
        }
    }

    return false;
}

bool PrivateKey::isValid(const Data& data, TWCurve curve)
{
    // check size
    bool valid = isValid(data);
    if (!valid) {
        return false;
    }

    const ecdsa_curve *ec_curve = nullptr;
    switch (curve)
    {
    case TWCurveSECP256k1:
        ec_curve = &secp256k1;
        break;
    case TWCurveNIST256p1:
        ec_curve = &nist256p1;
        break;
    case TWCurveED25519:
    case TWCurveED25519Blake2bNano:
    case TWCurveED25519Extended:
    case TWCurveCurve25519:
    case TWCurveNone:
    default:
        break;
    }

    if (ec_curve != nullptr) {
        bignum256 k;
        bn_read_be(data.data(), &k);
        if (!bn_is_less(&k, &ec_curve->order)) {
            memzero(&k, sizeof(k));
            return false;
        };
    }

    return true;
}

PrivateKey::PrivateKey(const Data& data) {
    if (!isValid(data)) {
        throw std::invalid_argument("Invalid private key data");
    }
    if (data.size() == extendedSize) {
        // special extended case
        *this = PrivateKey(
            TW::data(data.data(), 32),
            TW::data(data.data() + 32, 32),
            TW::data(data.data() + 64, 32));
    } else {
        // default case
        bytes = data;
    }
}

PrivateKey::PrivateKey(const Data& data, const Data& ext, const Data& chainCode) {
    if (!isValid(data) || !isValid(ext) || !isValid(chainCode)) {
        throw std::invalid_argument("Invalid private key or extended key data");
    }
    bytes = data;
    extensionBytes = ext;
    chainCodeBytes = chainCode;
}

PublicKey PrivateKey::getPublicKey(TWPublicKeyType type) const {
    Data result;
    switch (type) {
    case TWPublicKeyTypeSECP256k1:
        result.resize(PublicKey::secp256k1Size);
        ecdsa_get_public_key33(&secp256k1, bytes.data(), result.data());
        break;
    case TWPublicKeyTypeSECP256k1Extended:
        result.resize(PublicKey::secp256k1ExtendedSize);
        ecdsa_get_public_key65(&secp256k1, bytes.data(), result.data());
        break;
    case TWPublicKeyTypeNIST256p1:
        result.resize(PublicKey::secp256k1Size);
        ecdsa_get_public_key33(&nist256p1, bytes.data(), result.data());
        break;
    case TWPublicKeyTypeNIST256p1Extended:
        result.resize(PublicKey::secp256k1ExtendedSize);
        ecdsa_get_public_key65(&nist256p1, bytes.data(), result.data());
        break;
    case TWPublicKeyTypeED25519:
        result.resize(PublicKey::ed25519Size);
        ed25519_publickey(bytes.data(), result.data());
        break;
    case TWPublicKeyTypeED25519Blake2b:
        result.resize(PublicKey::ed25519Size);
        ed25519_publickey_blake2b(bytes.data(), result.data());
        break;
    case TWPublicKeyTypeED25519Extended:
        // must be extended key
        if (bytes.size() + extensionBytes.size() + chainCodeBytes.size() != extendedSize) {
            throw std::invalid_argument("Invalid extended key");
        }
        result.resize(PublicKey::ed25519ExtendedSize);
        ed25519_publickey_ext(bytes.data(), extensionBytes.data(), result.data());
        // append chainCode to the end of the public key
        std::copy(chainCodeBytes.begin(), chainCodeBytes.end(), result.begin() + 32);
        break;
    case TWPublicKeyTypeCURVE25519:
        result.resize(PublicKey::ed25519Size);
        PublicKey ed25519PublicKey = getPublicKey(TWPublicKeyTypeED25519);
        ed25519_pk_to_curve25519(result.data(), ed25519PublicKey.bytes.data());
        break;
    }
    return PublicKey(result, type);
}

Data PrivateKey::getSharedKey(const PublicKey& pubKey, TWCurve curve) const {
    if (curve != TWCurveSECP256k1) {
        return {};
    }

    Data result(PublicKey::secp256k1ExtendedSize);
    bool success = ecdh_multiply(&secp256k1, bytes.data(),
                                 pubKey.bytes.data(), result.data()) == 0;

    if (success) {
        PublicKey sharedKey(result, TWPublicKeyTypeSECP256k1Extended);
        auto hash = Hash::sha256(sharedKey.compressed().bytes);
        return hash;
    }

    return {};
}

int ecdsa_sign_digest_checked(const ecdsa_curve *curve, const uint8_t *priv_key, const uint8_t *digest, size_t digest_size, uint8_t *sig, uint8_t *pby, int (*is_canonical)(uint8_t by, uint8_t sig[64])) {
    if (digest_size < 32) {
        return -1;
    }
    assert(digest_size >= 32);
    return ecdsa_sign_digest(curve, priv_key, digest, sig, pby, is_canonical);
}

Data PrivateKey::sign(const Data& digest, TWCurve curve) const {
    Data result;
    bool success = false;
    switch (curve) {
    case TWCurveSECP256k1: {
        result.resize(65);
        success = ecdsa_sign_digest_checked(&secp256k1, bytes.data(), digest.data(), digest.size(), result.data(),
                                    result.data() + 64, nullptr) == 0;
    } break;
    case TWCurveED25519: {
        result.resize(64);
        const auto publicKey = getPublicKey(TWPublicKeyTypeED25519);
        ed25519_sign(digest.data(), digest.size(), bytes.data(), publicKey.bytes.data(), result.data());
        success = true;
    } break;
    case TWCurveED25519Blake2bNano: {
        result.resize(64);
        const auto publicKey = getPublicKey(TWPublicKeyTypeED25519Blake2b);
        ed25519_sign_blake2b(digest.data(), digest.size(), bytes.data(),
                             publicKey.bytes.data(), result.data());
        success = true;
    } break;
    case TWCurveED25519Extended: {
        result.resize(64);
        const auto publicKey = getPublicKey(TWPublicKeyTypeED25519Extended);
        ed25519_sign_ext(digest.data(), digest.size(), bytes.data(), extensionBytes.data(), publicKey.bytes.data(), result.data());
        success = true;
    } break;
    case TWCurveCurve25519: {
        result.resize(64);
        const auto publicKey = getPublicKey(TWPublicKeyTypeED25519);
        ed25519_sign(digest.data(), digest.size(), bytes.data(), publicKey.bytes.data(),
                     result.data());
        const auto sign_bit = publicKey.bytes[31] & 0x80;
        result[63] = result[63] & 127;
        result[63] |= sign_bit;
        success = true;
    } break;
    case TWCurveNIST256p1: {
        result.resize(65);
        success = ecdsa_sign_digest_checked(&nist256p1, bytes.data(), digest.data(), digest.size(), result.data(),
                                    result.data() + 64, nullptr) == 0;
    } break;
    case TWCurveNone:
    default: 
        break;
    }

    if (!success) {
        return {};
    }
    return result;
}

Data PrivateKey::sign(const Data& digest, TWCurve curve, int(*canonicalChecker)(uint8_t by, uint8_t sig[64])) const {
    Data result;
    bool success = false;
    switch (curve) {
    case TWCurveSECP256k1: {
        result.resize(65);
        success = ecdsa_sign_digest_checked(&secp256k1, bytes.data(), digest.data(), digest.size(), result.data() + 1,
                                    result.data(), canonicalChecker) == 0;
    } break;
    case TWCurveED25519: // not supported
    case TWCurveED25519Blake2bNano: // not supported
    case TWCurveED25519Extended: // not supported
    case TWCurveCurve25519:         // not supported
        break;
    case TWCurveNIST256p1: {
        result.resize(65);
        success = ecdsa_sign_digest_checked(&nist256p1, bytes.data(), digest.data(), digest.size(), result.data() + 1,
                                    result.data(), canonicalChecker) == 0;
    } break;
    case TWCurveNone:
    default:
        break;
    }

    if (!success) {
        return {};
    }

    // graphene adds 31 to the recovery id
    result[0] += 31;
    return result;
}

Data PrivateKey::signAsDER(const Data& digest, TWCurve curve) const {
    Data sig(64);
    bool success =
        ecdsa_sign_digest(&secp256k1, bytes.data(), digest.data(), sig.data(), nullptr, nullptr) == 0;
    if (!success) {
        return {};
    }

    Data resultBytes(72);
    size_t size = ecdsa_sig_to_der(sig.data(), resultBytes.data());

    auto result = Data{};
    std::copy(resultBytes.begin(), resultBytes.begin() + size, std::back_inserter(result));
    return result;
}

Data PrivateKey::signSchnorr(const Data& message, TWCurve curve) const {
    bool success = false;
    Data sig(64);
    switch (curve) {
    case TWCurveSECP256k1: {
        success = zil_schnorr_sign(&secp256k1, bytes.data(), message.data(), static_cast<uint32_t>(message.size()), sig.data()) == 0;
    } break;

    case TWCurveNIST256p1:
    case TWCurveED25519:
    case TWCurveED25519Blake2bNano:
    case TWCurveED25519Extended:
    case TWCurveCurve25519:
    case TWCurveNone:
    default:
        // not support
        break;
    }

    if (!success) {
        return {};
    }
    return sig;
}

void PrivateKey::cleanup() {
    std::fill(bytes.begin(), bytes.end(), 0);
    std::fill(extensionBytes.begin(), extensionBytes.end(), 0);
    std::fill(chainCodeBytes.begin(), chainCodeBytes.end(), 0);
}
#include "Base64.h"

#include <boost/algorithm/string.hpp>
#include <boost/archive/iterators/base64_from_binary.hpp>
#include <boost/archive/iterators/binary_from_base64.hpp>
#include <boost/archive/iterators/transform_width.hpp>

namespace TW::Base64 {

using namespace TW;
using namespace std;

Data decode(const string& val) {
    using namespace boost::archive::iterators;
    using It = transform_width<binary_from_base64<string::const_iterator>, 8, 6>;
    return boost::algorithm::trim_right_copy_if(Data(It(begin(val)), It(end(val))),
                                                [](char c) { return c == '\0'; });
}

string encode(const Data& val) {
    using namespace boost::archive::iterators;
    using It = base64_from_binary<transform_width<Data::const_iterator, 6, 8>>;
    auto encoded = string(It(begin(val)), It(end(val)));
    return encoded.append((3 - val.size() % 3) % 3, '=');
}

/// Convert from Base64Url format to regular
void convertFromBase64Url(string& b) {
    // '-' and '_' (Base64URL format) are changed to '+' and '/'
    // in-place replace
    size_t n = b.length();
    char* start = b.data();
    char* end = start + n;
    for(auto p = start; p < end; ++p) {
        if (*p == '-') { *p = '+'; }
        else if (*p == '_') { *p = '/'; }
    }
}

/// Convert from regular format to Base64Url
void convertToBase64Url(string& b) {
    // '+' and '/' are changed to '-' and '_' (Base64URL format)
    // in-place replace
    size_t n = b.length();
    char* start = b.data();
    char* end = start + n;
    for(auto p = start; p < end; ++p) {
        if (*p == '+') { *p = '-'; }
        else if (*p == '/') { *p = '_'; }
    }
}

Data decodeBase64Url(const string& val) {
    Data bytes;
    try {
        return decode(val);
    } catch (const exception& ex) {
        // 2nd try: Base64URL format (replaced by '-' and '_' by '+' and '/' )
        string base64Url = val;
        convertFromBase64Url(base64Url);
        return decode(base64Url);
    }
}

string encodeBase64Url(const Data& val) {
    using namespace boost::archive::iterators;
    using It = base64_from_binary<transform_width<Data::const_iterator, 6, 8>>;
    auto encoded = string(It(begin(val)), It(end(val)));
    encoded.append((3 - val.size() % 3) % 3, '=');
    convertToBase64Url(encoded);
    return encoded;
}

} //
[
  {
    "id": "bitcoin",
    "name": "Bitcoin",
    "coinId": 0,
    "symbol": "BTC",
    "decimals": 8,
    "blockchain": "Bitcoin",
    "derivationPath": "m/84'/0'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1",
    "p2pkhPrefix": 0,
    "p2shPrefix": 5,
    "hrp": "bc",
    "publicKeyHasher": "sha256ripemd",
    "base58Hasher": "sha256d",
    "xpub": "zpub",
    "xprv": "zprv",
    "explorer": {
      "url": "https://blockchair.com",
      "txPath": "/bitcoin/transaction/",
      "accountPath": "/bitcoin/address/",
      "sampleTx": "0607f62530b68cfcc91c57a1702841dd399a899d0eecda8e31ecca3f52f01df2",
      "sampleAccount": "17A16QmavnUfCW11DAApiJxp7ARnxN5pGX"
    },
    "info": {
      "url": "https://bitcoin.org",
      "source": "https://github.com/trezor/blockbook",
      "rpc": "",
      "documentation": "https://github.com/trezor/blockbook/blob/master/docs/api.md"
    }
  },
  {
    "id": "litecoin",
    "name": "Litecoin",
    "coinId": 2,
    "symbol": "LTC",
    "decimals": 8,
    "blockchain": "Bitcoin",
    "derivationPath": "m/84'/2'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1",
    "p2pkhPrefix": 48,
    "p2shPrefix": 50,
    "hrp": "ltc",
    "publicKeyHasher": "sha256ripemd",
    "base58Hasher": "sha256d",
    "xpub": "zpub",
    "xprv": "zprv",
    "explorer": {
      "url": "https://blockchair.com",
      "txPath": "/litecoin/transaction/",
      "accountPath": "/litecoin/address/"
    },
    "info": {
      "url": "https://litecoin.org",
      "source": "https://github.com/trezor/blockbook",
      "rpc": "",
      "documentation": "https://github.com/trezor/blockbook/blob/master/docs/api.md"
    }
  },
  {
    "id": "doge",
    "name": "Dogecoin",
    "coinId": 3,
    "symbol": "DOGE",
    "decimals": 8,
    "blockchain": "Bitcoin",
    "derivationPath": "m/44'/3'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1",
    "p2pkhPrefix": 30,
    "p2shPrefix": 22,
    "publicKeyHasher": "sha256ripemd",
    "base58Hasher": "sha256d",
    "xpub": "dgub",
    "xprv": "dgpv",
    "explorer": {
      "url": "https://blockchair.com",
      "txPath": "/dogecoin/transaction/",
      "accountPath": "/dogecoin/address/"
    },
    "info": {
      "url": "https://dogecoin.com",
      "source": "https://github.com/trezor/blockbook",
      "rpc": "",
      "documentation": "https://github.com/trezor/blockbook/blob/master/docs/api.md"
    }
  },
  {
    "id": "dash",
    "name": "Dash",
    "coinId": 5,
    "symbol": "DASH",
    "decimals": 8,
    "blockchain": "Bitcoin",
    "derivationPath": "m/44'/5'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1",
    "p2pkhPrefix": 76,
    "p2shPrefix": 16,
    "publicKeyHasher": "sha256ripemd",
    "base58Hasher": "sha256d",
    "xpub": "xpub",
    "xprv": "xprv",
    "explorer": {
      "url": "https://blockchair.com",
      "txPath": "/dash/transaction/",
      "accountPath": "/dash/address/"
    },
    "info": {
      "url": "https://dash.org",
      "source": "https://github.com/trezor/blockbook",
      "rpc": "",
      "documentation": "https://github.com/trezor/blockbook/blob/master/docs/api.md"
    }
  },
  {
    "id": "viacoin",
    "name": "Viacoin",
    "coinId": 14,
    "symbol": "VIA",
    "decimals": 8,
    "blockchain": "Bitcoin",
    "derivationPath": "m/84'/14'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1",
    "p2pkhPrefix": 71,
    "p2shPrefix": 33,
    "hrp": "via",
    "publicKeyHasher": "sha256ripemd",
    "base58Hasher": "sha256d",
    "xpub": "zpub",
    "xprv": "zprv",
    "explorer": {
      "url": "https://explorer.viacoin.org",
      "txPath": "/tx/",
      "accountPath": "/address/"
    },
    "info": {
      "url": "https://viacoin.org",
      "source": "https://github.com/trezor/blockbook",
      "rpc": "",
      "documentation": "https://github.com/trezor/blockbook/blob/master/docs/api.md"
    }
  },
  {
    "id": "groestlcoin",
    "name": "Groestlcoin",
    "coinId": 17,
    "symbol": "GRS",
    "decimals": 8,
    "blockchain": "Bitcoin",
    "derivationPath": "m/84'/17'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1",
    "p2pkhPrefix": 36,
    "p2shPrefix": 5,
    "hrp": "grs",
    "publicKeyHasher": "sha256ripemd",
    "base58Hasher": "groestl512d",
    "xpub": "zpub",
    "xprv": "zprv",
    "explorer": {
      "url": "https://blockchair.com",
      "txPath": "/groestlcoin/transaction/",
      "accountPath": "/groestlcoin/address/"
    },
    "info": {
      "url": "https://www.groestlcoin.org",
      "source": "https://github.com/trezor/blockbook",
      "rpc": "",
      "documentation": "https://github.com/trezor/blockbook/blob/master/docs/api.md"
    }
  },
  {
    "id": "digibyte",
    "name": "DigiByte",
    "coinId": 20,
    "symbol": "DGB",
    "decimals": 8,
    "blockchain": "Bitcoin",
    "derivationPath": "m/84'/20'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1",
    "p2pkhPrefix": 30,
    "p2shPrefix": 63,
    "hrp": "dgb",
    "publicKeyHasher": "sha256ripemd",
    "base58Hasher": "sha256d",
    "xpub": "zpub",
    "xprv": "zprv",
    "explorer": {
      "url": "https://digiexplorer.info",
      "txPath": "/tx/",
      "accountPath": "/address/"
    },
    "info": {
      "url": "https://www.digibyte.io",
      "source": "https://github.com/trezor/blockbook",
      "rpc": "",
      "documentation": "https://github.com/trezor/blockbook/blob/master/docs/api.md"
    }
  },
  {
    "id": "monacoin",
    "name": "Monacoin",
    "coinId": 22,
    "symbol": "MONA",
    "decimals": 8,
    "blockchain": "Bitcoin",
    "derivationPath": "m/44'/22'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1",
    "p2pkhPrefix": 50,
    "p2shPrefix": 55,
    "hrp": "mona",
    "publicKeyHasher": "sha256ripemd",
    "base58Hasher": "sha256d",
    "xpub": "xpub",
    "xprv": "xprv",
    "explorer": {
      "url": "https://blockbook.electrum-mona.org",
      "txPath": "/tx/",
      "accountPath": "/address/"
    },
    "info": {
      "url": "https://monacoin.org",
      "source": "https://github.com/trezor/blockbook",
      "rpc": "",
      "documentation": "https://github.com/trezor/blockbook/blob/master/docs/api.md"
    }
  },
  {
    "id": "decred",
    "name": "Decred",
    "coinId": 42,
    "symbol": "DCR",
    "decimals": 8,
    "blockchain": "Bitcoin",
    "derivationPath": "m/44'/42'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1",
    "staticPrefix": 7,
    "p2pkhPrefix": 63,
    "p2shPrefix": 26,
    "publicKeyHasher": "blake256ripemd",
    "base58Hasher": "blake256d",
    "xpub": "dpub",
    "xprv": "dprv",
    "explorer": {
      "url": "https://dcrdata.decred.org",
      "txPath": "/tx/",
      "accountPath": "/address/"
    },
    "info": {
      "url": "https://decred.org",
      "source": "https://github.com/trezor/blockbook",
      "rpc": "",
      "documentation": "https://github.com/trezor/blockbook/blob/master/docs/api.md"
    }
  },
  {
    "id": "ethereum",
    "name": "Ethereum",
    "coinId": 60,
    "symbol": "ETH",
    "decimals": 18,
    "blockchain": "Ethereum",
    "derivationPath": "m/44'/60'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1Extended",
    "explorer": {
      "url": "https://etherscan.io",
      "txPath": "/tx/",
      "accountPath": "/address/",
      "sampleTx": "0x9edaf0f7d9c6629c31bbf0471fc07d696c73b566b93783f7e25d8d5d2b62fa4f",
      "sampleAccount": "0x5bb497e8d9fe26e92dd1be01e32076c8e024d167"
    },
    "info": {
      "url": "https://ethereum.org",
      "source": "https://github.com/ethereum/go-ethereum",
      "rpc": "https://mainnet.infura.io",
      "documentation": "https://eth.wiki/json-rpc/API"
    }
  },
  {
    "id": "classic",
    "name": "Ethereum Classic",
    "coinId": 61,
    "symbol": "ETC",
    "decimals": 18,
    "blockchain": "Ethereum",
    "derivationPath": "m/44'/61'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1Extended",
    "explorer": {
      "url": "https://blockscout.com/etc/mainnet",
      "txPath": "/tx/",
      "accountPath": "/address/"
    },
    "info": {
      "url": "https://ethereumclassic.org",
      "source": "https://github.com/ethereumclassic/go-ethereum",
      "rpc": "https://www.ethercluster.com/etc",
      "documentation": "https://eth.wiki/json-rpc/API"
    }
  },
  {
    "id": "icon",
    "name": "ICON",
    "coinId": 74,
    "symbol": "ICX",
    "decimals": 18,
    "blockchain": "Icon",
    "derivationPath": "m/44'/74'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1Extended",
    "explorer": {
      "url": "https://tracker.icon.foundation",
      "txPath": "/transaction/",
      "accountPath": "/address/"
    },
    "info": {
      "url": "https://icon.foundation",
      "source": "https://github.com/icon-project/icon-rpc-server",
      "rpc": "http://ctz.icxstation.com:9000/api/v3",
      "documentation": "https://www.icondev.io/docs/icon-json-rpc-v3"
    }
  },
  {
    "id": "cosmos",
    "name": "Cosmos",
    "coinId": 118,
    "symbol": "ATOM",
    "decimals": 6,
    "blockchain": "Cosmos",
    "derivationPath": "m/44'/118'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1",
    "hrp": "cosmos",
    "explorer": {
      "url": "https://www.mintscan.io",
      "txPath": "/txs/",
      "accountPath": "/account/"
    },
    "info": {
      "url": "https://cosmos.network",
      "source": "https://github.com/cosmos/cosmos-sdk",
      "rpc": "https://stargate.cosmos.network",
      "documentation": "https://cosmos.network/rpc"
    }
  },
  {
    "id": "zcash",
    "name": "Zcash",
    "coinId": 133,
    "symbol": "ZEC",
    "decimals": 8,
    "blockchain": "Bitcoin",
    "derivationPath": "m/44'/133'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1",
    "staticPrefix": 28,
    "p2pkhPrefix": 184,
    "p2shPrefix": 189,
    "publicKeyHasher": "sha256ripemd",
    "base58Hasher": "sha256d",
    "xpub": "xpub",
    "xprv": "xprv",
    "explorer": {
      "url": "https://blockchair.com/zcash",
      "txPath": "/transaction/",
      "accountPath": "/address/"
    },
    "info": {
      "url": "https://z.cash",
      "source": "https://github.com/trezor/blockbook",
      "rpc": "",
      "documentation": "https://github.com/trezor/blockbook/blob/master/docs/api.md"
    }
  },
  {
    "id": "zcoin",
    "name": "Zcoin",
    "displayName": "Firo",
    "coinId": 136,
    "symbol": "FIRO",
    "decimals": 8,
    "blockchain": "Bitcoin",
    "derivationPath": "m/44'/136'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1",
    "p2pkhPrefix": 82,
    "p2shPrefix": 7,
    "publicKeyHasher": "sha256ripemd",
    "base58Hasher": "sha256d",
    "xpub": "xpub",
    "xprv": "xprv",
    "explorer": {
      "url": "https://explorer.firo.org",
      "txPath": "/tx/",
      "accountPath": "/address/"
    },
    "info": {
      "url": "https://firo.org/",
      "source": "https://github.com/firoorg/firo",
      "rpc": "",
      "documentation": "https://github.com/trezor/blockbook/blob/master/docs/api.md"
    }
  },
  {
    "id": "ripple",
    "name": "XRP",
    "coinId": 144,
    "symbol": "XRP",
    "decimals": 6,
    "blockchain": "Ripple",
    "derivationPath": "m/44'/144'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1",
    "explorer": {
      "url": "https://bithomp.com",
      "txPath": "/explorer/",
      "accountPath": "/explorer/",
      "sampleTx": "E26AB8F3372D2FC02DEC1FD5674ADAB762D684BFFDBBDF5D674E9D7CF4A47054",
      "sampleAccount": "rfkH7EuS1XcSkB9pocy1R6T8F4CsNYixYU"
    },
    "info": {
      "url": "https://ripple.com/xrp",
      "source": "https://github.com/ripple/rippled",
      "rpc": "https://s2.ripple.com:51234",
      "documentation": "https://xrpl.org/rippled-api.html"
    }
  },
  {
    "id": "bitcoincash",
    "name": "Bitcoin Cash",
    "coinId": 145,
    "symbol": "BCH",
    "decimals": 8,
    "blockchain": "Bitcoin",
    "derivationPath": "m/44'/145'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1",
    "p2pkhPrefix": 0,
    "p2shPrefix": 5,
    "hrp": "bitcoincash",
    "publicKeyHasher": "sha256ripemd",
    "base58Hasher": "sha256d",
    "xpub": "xpub",
    "xprv": "xprv",
    "explorer": {
      "url": "https://blockchair.com",
      "txPath": "/bitcoin-cash/transaction/",
      "accountPath": "/bitcoin-cash/address/"
    },
    "info": {
      "url": "https://bitcoincash.org",
      "source": "https://github.com/trezor/blockbook",
      "rpc": "",
      "documentation": "https://github.com/trezor/blockbook/blob/master/docs/api.md"
    }
  },
  {
    "id": "stellar",
    "name": "Stellar",
    "coinId": 148,
    "symbol": "XLM",
    "decimals": 7,
    "blockchain": "Stellar",
    "derivationPath": "m/44'/148'/0'",
    "curve": "ed25519",
    "publicKeyType": "ed25519",
    "explorer": {
      "url": "https://blockchair.com/stellar",
      "txPath": "/transaction/",
      "accountPath": "/account/"
    },
    "info": {
      "url": "https://stellar.org",
      "source": "https://github.com/stellar/go",
      "rpc": "https://horizon.stellar.org",
      "documentation": "https://www.stellar.org/developers/horizon/reference"
    }
  },
  {
    "id": "bitcoingold",
    "name": "Bitcoin Gold",
    "coinId": 156,
    "symbol": "BTG",
    "decimals": 8,
    "blockchain": "Bitcoin",
    "derivationPath": "m/84'/156'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1",
    "p2pkhPrefix": 38,
    "p2shPrefix": 23,
    "hrp": "btg",
    "publicKeyHasher": "sha256ripemd",
    "base58Hasher": "sha256d",
    "xpub": "zpub",
    "xprv": "zprv",
    "explorer": {
      "url": "https://explorer.bitcoingold.org/insight",
      "txPath": "/tx/",
      "accountPath": "/address/"
    },
    "info": {
      "url": "https://bitcoingold.org",
      "source": "https://github.com/trezor/blockbook",
      "rpc": "",
      "documentation": "https://github.com/trezor/blockbook/blob/master/docs/api.md"
    }
  },
  {
    "id": "nano",
    "name": "Nano",
    "coinId": 165,
    "symbol": "NANO",
    "decimals": 30,
    "blockchain": "Nano",
    "derivationPath": "m/44'/165'/0'",
    "curve": "ed25519Blake2bNano",
    "publicKeyType": "ed25519Blake2b",
    "url": "https://nano.org",
    "explorer": {
      "url": "https://nanocrawler.cc",
      "txPath": "/explorer/block/",
      "accountPath": "/explorer/account/",
      "sampleTx": "C264DB7BF40738F0CEFF19B606746CB925B713E4B8699A055699E0DC8ABBC70F",
      "sampleAccount": "nano_1wpj616kwhe1y38y1mspd8aub8i334cwybqco511iyuxm55zx8d67ptf1tsf"
    },
    "info": {
      "url": "https://nano.org",
      "source": "https://github.com/nanocurrency/nano-node",
      "rpc": "",
      "documentation": "https://docs.nano.org/commands/rpc-protocol/"
    }
  },
  {
    "id": "ravencoin",
    "name": "Ravencoin",
    "coinId": 175,
    "symbol": "RVN",
    "decimals": 8,
    "blockchain": "Bitcoin",
    "derivationPath": "m/44'/175'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1",
    "p2pkhPrefix": 60,
    "p2shPrefix": 122,
    "publicKeyHasher": "sha256ripemd",
    "base58Hasher": "sha256d",
    "xpub": "xpub",
    "xprv": "xprv",
    "explorer": {
      "url": "https://ravencoin.network",
      "txPath": "/tx/",
      "accountPath": "/address/"
    },
    "info": {
      "url": "https://ravencoin.org",
      "source": "https://github.com/trezor/blockbook",
      "rpc": "",
      "documentation": "https://github.com/trezor/blockbook/blob/master/docs/api.md"
    }
  },
  {
    "id": "poa",
    "name": "POA Network",
    "coinId": 178,
    "symbol": "POA",
    "decimals": 18,
    "blockchain": "Ethereum",
    "derivationPath": "m/44'/178'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1Extended",
    "explorer": {
      "url": "https://blockscout.com",
      "txPath": "/poa/core/tx/",
      "accountPath": "/poa/core/address/"
    },
    "info": {
      "url": "https://poa.network",
      "source": "https://github.com/poanetwork/parity-ethereum",
      "rpc": "https://core.poa.network",
      "documentation": "https://eth.wiki/json-rpc/API"
    }
  },
  {
    "id": "eos",
    "name": "EOS",
    "coinId": 194,
    "symbol": "EOS",
    "decimals": 4,
    "blockchain": "EOS",
    "derivationPath": "m/44'/194'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1",
    "explorer": {
      "url": "https://bloks.io",
      "txPath": "/transaction/",
      "accountPath": "/account/"
    },
    "info": {
      "url": "http://eos.io",
      "source": "https://github.com/eosio/eos",
      "rpc": "",
      "documentation": "https://developers.eos.io/eosio-nodeos/reference"
    }
  },
  {
    "id": "tron",
    "name": "Tron",
    "coinId": 195,
    "symbol": "TRX",
    "decimals": 6,
    "blockchain": "Tron",
    "derivationPath": "m/44'/195'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1Extended",
    "explorer": {
      "url": "https://tronscan.org",
      "txPath": "/#/transaction/",
      "accountPath": "/#/address/"
    },
    "info": {
      "url": "https://tron.network",
      "source": "https://github.com/tronprotocol/java-tron",
      "rpc": "https://api.trongrid.io",
      "documentation": "https://developers.tron.network/docs/tron-wallet-rpc-api"
    }
  },
  {
    "id": "fio",
    "name": "FIO",
    "coinId": 235,
    "symbol": "FIO",
    "decimals": 9,
    "blockchain": "FIO",
    "derivationPath": "m/44'/235'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1",
    "url": "https://fioprotocol.io/",
    "explorer": {
      "url": "https://explorer.fioprotocol.io",
      "txPath": "/transaction/",
      "accountPath": "/account/"
    },
    "info": {
      "url": "https://fioprotocol.io",
      "source": "https://github.com/fioprotocol/fio",
      "rpc": "https://mainnet.fioprotocol.io",
      "documentation": "https://developers.fioprotocol.io"
    }
  },
  {
    "id": "nimiq",
    "name": "Nimiq",
    "coinId": 242,
    "symbol": "NIM",
    "decimals": 5,
    "blockchain": "Nimiq",
    "derivationPath": "m/44'/242'/0'/0'",
    "curve": "ed25519",
    "publicKeyType": "ed25519",
    "explorer": {
      "url": "https://nimiq.watch",
      "txPath": "/#",
      "accountPath": "/#"
    },
    "info": {
      "url": "https://nimiq.com",
      "source": "https://github.com/nimiq/core-rs",
      "rpc": "",
      "documentation": "https://github.com/nimiq/core-js/wiki/JSON-RPC-API"
    }
  },
  {
    "id": "algorand",
    "name": "Algorand",
    "coinId": 283,
    "symbol": "ALGO",
    "decimals": 6,
    "blockchain": "Algorand",
    "derivationPath": "m/44'/283'/0'/0'/0'",
    "curve": "ed25519",
    "publicKeyType": "ed25519",
    "explorer": {
      "url": "https://algoexplorer.io",
      "txPath": "/tx/",
      "accountPath": "/address/",
      "sampleTx": "CR7POXFTYDLC7TV3IXHA7AZKWABUJC52BACLHJQNXAKZJGRPQY3A",
      "sampleAccount": "J4AEINCSSLDA7LNBNWM4ZXFCTLTOZT5LG3F5BLMFPJYGFWVCMU37EZI2AM"
    },
    "info": {
      "url": "https://www.algorand.com/",
      "source": "https://github.com/algorand/go-algorand",
      "rpc": "https://indexer.algorand.network",
      "documentation": "https://developer.algorand.org/docs/algod-rest-paths"
    }
  },
  {
    "id": "iotex",
    "name": "IoTeX",
    "coinId": 304,
    "symbol": "IOTX",
    "decimals": 18,
    "blockchain": "IoTeX",
    "derivationPath": "m/44'/304'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1Extended",
    "hrp": "io",
    "explorer": {
      "url": "https://iotexscan.io",
      "txPath": "/action/",
      "accountPath": "/address/"
    },
    "info": {
      "url": "https://iotex.io",
      "source": "https://github.com/iotexproject/iotex-core",
      "rpc": "",
      "documentation": "https://docs.iotex.io/#api"
    }
  },
  {
    "id": "zilliqa",
    "name": "Zilliqa",
    "coinId": 313,
    "symbol": "ZIL",
    "decimals": 12,
    "blockchain": "Zilliqa",
    "derivationPath": "m/44'/313'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1",
    "hrp": "zil",
    "explorer": {
      "url": "https://viewblock.io",
      "txPath": "/zilliqa/tx/",
      "accountPath": "/zilliqa/address/"
    },
    "info": {
      "url": "https://zilliqa.com",
      "source": "https://github.com/Zilliqa/Zilliqa",
      "rpc": "https://api.zilliqa.com",
      "documentation": "https://apidocs.zilliqa.com"
    }
  },
  {
    "id": "terra",
    "name": "Terra",
    "coinId": 330,
    "symbol": "LUNA",
    "decimals": 6,
    "blockchain": "Cosmos",
    "derivationPath": "m/44'/330'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1",
    "hrp": "terra",
    "explorer": {
      "url": "https://terra.stake.id",
      "txPath": "/#/tx/",
      "accountPath": "/#/address/"
    },
    "info": {
      "url": "https://terra.money",
      "source": "https://github.com/terra-project/core",
      "rpc": "https://rpc.terra.dev",
      "documentation": "https://docs.terra.money"
    }
  },
  {
    "id": "polkadot",
    "name": "Polkadot",
    "coinId": 354,
    "symbol": "DOT",
    "decimals": 10,
    "blockchain": "Polkadot",
    "derivationPath": "m/44'/354'/0'/0'/0'",
    "curve": "ed25519",
    "publicKeyType": "ed25519",
    "explorer": {
      "url": "https://polkadot.subscan.io",
      "txPath": "/extrinsic/",
      "accountPath": "/account/"
    },
    "info": {
      "url": "https://polkadot.network/",
      "source": "https://github.com/paritytech/polkadot",
      "rpc": "",
      "documentation": "https://polkadot.js.org/api/substrate/rpc.html"
    }
  },
  {
    "id": "near",
    "name": "NEAR",
    "coinId": 397,
    "symbol": "NEAR",
    "decimals": 24,
    "blockchain": "NEAR",
    "derivationPath": "m/44'/397'/0'",
    "curve": "ed25519",
    "publicKeyType": "ed25519",
    "explorer": {
      "url": "https://explorer.near.org",
      "txPath": "/transactions/",
      "accountPath": "/accounts/"
    },
    "info": {
      "url": "https://nearprotocol.com",
      "source": "https://github.com/nearprotocol/nearcore",
      "rpc": "https://rpc.nearprotocol.com",
      "documentation": "https://docs.nearprotocol.com"
    }
  },
  {
    "id": "aion",
    "name": "Aion",
    "coinId": 425,
    "symbol": "AION",
    "decimals": 18,
    "blockchain": "Aion",
    "derivationPath": "m/44'/425'/0'/0'/0'",
    "curve": "ed25519",
    "publicKeyType": "ed25519",
    "explorer": {
      "url": "https://mainnet.aion.network",
      "txPath": "/#/transaction/",
      "accountPath": "/#/account/"
    },
    "info": {
      "url": "https://aion.network",
      "source": "https://github.com/aionnetwork/aion",
      "rpc": "",
      "documentation": "https://github.com/aionnetwork/aion/wiki/JSON-RPC-API-Docs"
    }
  },
  {
    "id": "kusama",
    "name": "Kusama",
    "coinId": 434,
    "symbol": "KSM",
    "decimals": 12,
    "blockchain": "Polkadot",
    "derivationPath": "m/44'/434'/0'/0'/0'",
    "curve": "ed25519",
    "publicKeyType": "ed25519",
    "explorer": {
      "url": "https://kusama.subscan.io",
      "txPath": "/extrinsic/",
      "accountPath": "/account/",
      "sampleTx": "0xcbe0c2e2851c1245bedaae4d52f06eaa6b4784b786bea2f0bff11af7715973dd",
      "sampleAccount": "DbCNECPna3k6MXFWWNZa5jGsuWycqEE6zcUxZYkxhVofrFk"
    },
    "info": {
      "url": "https://kusama.network",
      "source": "https://github.com/paritytech/polkadot",
      "rpc": "wss://kusama-rpc.polkadot.io/",
      "documentation": "https://polkadot.js.org/api/substrate/rpc.html"
    }
  },
  {
    "id": "aeternity",
    "name": "Aeternity",
    "coinId": 457,
    "symbol": "AE",
    "decimals": 18,
    "blockchain": "Aeternity",
    "derivationPath": "m/44'/457'/0'/0'/0'",
    "curve": "ed25519",
    "publicKeyType": "ed25519",
    "explorer": {
      "url": "https://explorer.aepps.com",
      "txPath": "/transactions/",
      "accountPath": "/account/transactions/"
    },
    "info": {
      "url": "https://aeternity.com",
      "source": "https://github.com/aeternity/aeternity",
      "rpc": "https://sdk-mainnet.aepps.com",
      "documentation": "http://aeternity.com/api-docs/"
    }
  },
  {
    "id": "kava",
    "name": "Kava",
    "coinId": 459,
    "symbol": "KAVA",
    "decimals": 6,
    "blockchain": "Cosmos",
    "derivationPath": "m/44'/459'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1",
    "hrp": "kava",
    "explorer": {
      "url": "https://kava.mintscan.io",
      "txPath": "/txs/",
      "accountPath": "/account/",
      "sampleTx": "2988DF83FCBFAA38179D583A96734CBD071541D6768221BB23111BC8136D5E6A",
      "sampleAccount": "kava1jf9aaj9myrzsnmpdr7twecnaftzmku2mdpy2a7"
    },
    "info": {
      "url": "https://kava.io",
      "source": "https://github.com/kava-labs/kava",
      "rpc": "https://data.kava.io",
      "documentation": "https://rpc.kava.io"
    }
  },
  {
    "id": "filecoin",
    "name": "Filecoin",
    "coinId": 461,
    "symbol": "FIL",
    "decimals": 18,
    "blockchain": "Filecoin",
    "derivationPath": "m/44'/461'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1Extended",
    "explorer": {
      "url": "https://filfox.info/en",
      "txPath": "/message/",
      "accountPath": "/address/",
      "sampleTx": "bafy2bzacedsgjcd6xfhrrymmfrqubb44otlyhvgqkgsh533d5j5hwniiqespm",
      "sampleAccount": "f1abjxfbp274xpdqcpuaykwkfb43omjotacm2p3za"
    },
    "info": {
      "url": "https://filecoin.io/",
      "source": "https://github.com/filecoin-project/lotus",
      "rpc": "",
      "documentation": "https://docs.lotu.sh"
    }
  },
  {
    "id": "bluzelle",
    "name": "Bluzelle",
    "coinId": 483,
    "symbol": "BLZ",
    "decimals": 6,
    "blockchain": "Cosmos",
    "derivationPath": "m/44'/483'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1",
    "hrp": "bluzelle",
    "explorer": {
      "url": "https://bigdipper.net.bluzelle.com",
      "txPath": "/transactions/",
      "accountPath": "/account/",
      "sampleTx": "AC026E0EC6E33A77D5EA6B9CEF9810699BC2AD8C5582E007E7857457C6D3B819",
      "sampleAccount": "bluzelle1q9cryfal7u3jvnq6er5ufety20xtzw6ycx2te9"
    },
    "info": {
      "url": "https://bluzelle.com",
      "source": "https://github.com/bluzelle",
      "rpc": "https://bluzelle.github.io/api/",
      "documentation": "https://docs.bluzelle.com/developers/"
    }
  },
  {
    "id": "band",
    "name": "BandChain",
    "symbol": "BAND",
    "coinId": 494,
    "decimals": 6,
    "blockchain": "Cosmos",
    "derivationPath": "m/44'/494'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1",
    "hrp": "band",
    "explorer": {
      "url": "https://scan-wenchang-testnet2.bandchain.org/",
      "txPath": "/tx/",
      "accountPath": "/account/",
      "sampleTx": "473264551D3063A9EC64EC251C61BE92DDDFCF6CC46D026D1E574D83D5447173",
      "sampleAccount": "band12nmsm9khdsv0tywge43q3zwj8kkj3hvup9rltp"
    },
    "info": {
      "url": "https://bandprotocol.com/",
      "source": "https://github.com/bandprotocol/bandchain",
      "rpc": "https://api-wt2-lb.bandchain.org",
      "documentation": "https://docs.bandchain.org/"
    }
  },
  {
    "id": "theta",
    "name": "Theta",
    "coinId": 500,
    "symbol": "THETA",
    "decimals": 18,
    "blockchain": "Theta",
    "derivationPath": "m/44'/500'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1Extended",
    "explorer": {
      "url": "https://explorer.thetatoken.org",
      "txPath": "/txs/",
      "accountPath": "/account/"
    },
    "info": {
      "url": "https://www.thetatoken.org",
      "source": "https://github.com/thetatoken/theta-protocol-ledger",
      "rpc": "",
      "documentation": "https://github.com/thetatoken/theta-mainnet-integration-guide/blob/master/docs/api.md#api-reference"
    }
  },
  {
    "id": "solana",
    "name": "Solana",
    "coinId": 501,
    "symbol": "SOL",
    "decimals": 9,
    "blockchain": "Solana",
    "derivationPath": "m/44'/501'/0'",
    "curve": "ed25519",
    "publicKeyType": "ed25519",
    "explorer": {
      "url": "https://solscan.io",
      "txPath": "/tx/",
      "accountPath": "/account/",
      "sampleTx": "5LmxrEKGchhMuYfw6Qut6CbsvE9pVfb8YvwZKvWssSesDVjHioBCmWKSJQh1WhvcM6CpemhpHNmEMA2a36rzwTa8",
      "sampleAccount": "Bxp8yhH9zNwxyE4UqxP7a7hgJ5xTZfxNNft7YJJ2VRjT"
    },
    "info": {
      "url": "https://solana.com",
      "source": "https://github.com/solana-labs/solana",
      "rpc": "https://api.mainnet-beta.solana.com",
      "documentation": "https://docs.solana.com"
    }
  },
  {
    "id": "elrond",
    "name": "Elrond",
    "coinId": 508,
    "symbol": "eGLD",
    "decimals": 18,
    "blockchain": "ElrondNetwork",
    "derivationPath": "m/44'/508'/0'/0'/0'",
    "curve": "ed25519",
    "publicKeyType": "ed25519",
    "hrp": "erd",
    "explorer": {
      "url": "https://explorer.elrond.com",
      "txPath": "/transactions/",
      "accountPath": "/address/"
    },
    "info": {
      "url": "https://elrond.com/",
      "source": "https://github.com/ElrondNetwork/elrond-go",
      "rpc": "https://api.elrond.com",
      "documentation": "https://docs.elrond.com"
    }
  },
  {
    "id": "binance",
    "name": "Binance",
    "displayName": "BNB",
    "coinId": 714,
    "symbol": "BNB",
    "decimals": 8,
    "blockchain": "Binance",
    "derivationPath": "m/44'/714'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1",
    "hrp": "bnb",
    "explorer": {
      "url": "https://explorer.binance.org",
      "txPath": "/tx/",
      "accountPath": "/address/",
      "sampleTx": "A93625C9F9ABEA1A8E31585B30BBB16C34FAE0D172EB5B6B2F834AF077BF06BB",
      "sampleAccount": "bnb1u7jm0cll5h3224y0tapwn6gf6pr49ytewx4gsz"
    },
    "info": {
      "url": "https://binance.org",
      "source": "https://github.com/binance-chain/node-binary",
      "rpc": "https://dex.binance.org",
      "documentation": "https://docs.binance.org/api-reference/dex-api/paths.html"
    }
  },
  {
    "id": "vechain",
    "name": "VeChain",
    "coinId": 818,
    "symbol": "VET",
    "decimals": 18,
    "blockchain": "Vechain",
    "derivationPath": "m/44'/818'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1Extended",
    "explorer": {
      "url": "https://explore.vechain.org",
      "txPath": "/transactions/",
      "accountPath": "/accounts/"
    },
    "info": {
      "url": "https://vechain.org",
      "source": "https://github.com/vechain/thor",
      "rpc": "",
      "documentation": "https://doc.vechainworld.io/docs"
    }
  },
  {
    "id": "callisto",
    "name": "Callisto",
    "coinId": 820,
    "symbol": "CLO",
    "decimals": 18,
    "blockchain": "Ethereum",
    "derivationPath": "m/44'/820'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1Extended",
    "explorer": {
      "url": "https://explorer2.callisto.network",
      "txPath": "/tx/",
      "accountPath": "/addr/"
    },
    "info": {
      "url": "https://callisto.network",
      "source": "https://github.com/EthereumCommonwealth/go-callisto",
      "rpc": "https://clo-geth.0xinfra.com",
      "documentation": "https://eth.wiki/json-rpc/API"
    }
  },
  {
    "id": "neo",
    "name": "NEO",
    "coinId": 888,
    "symbol": "NEO",
    "decimals": 8,
    "blockchain": "NEO",
    "derivationPath": "m/44'/888'/0'/0/0",
    "curve": "nist256p1",
    "publicKeyType": "nist256p1",
    "explorer": {
      "url": "https://neoscan.io",
      "txPath": "/transaction/",
      "accountPath": "/address/",
      "sampleTx": "e0ddf7c81c732df26180aca0c36d5868ad009fdbbe6e7a56ebafc14bba41cd53",
      "sampleAccount": "AcxuqWhTureEQGeJgbmtSWNAtssjMLU7pb"
    },
    "info": {
      "url": "https://neo.org",
      "source": "https://github.com/neo-project/neo",
      "rpc": "http://seed1.ngd.network:10332",
      "documentation": "https://neo.org/eco"
    }
  },
  {
    "id": "tomochain",
    "name": "TomoChain",
    "coinId": 889,
    "symbol": "TOMO",
    "decimals": 18,
    "blockchain": "Ethereum",
    "derivationPath": "m/44'/889'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1Extended",
    "explorer": {
      "url": "https://scan.tomochain.com",
      "txPath": "/txs/",
      "accountPath": "/address/"
    },
    "info": {
      "url": "https://tomochain.com",
      "source": "https://github.com/tomochain/tomochain",
      "rpc": "https://rpc.tomochain.com",
      "documentation": "https://eth.wiki/json-rpc/API"
    }
  },
  {
    "id": "thundertoken",
    "name": "Thunder Token",
    "coinId": 1001,
    "symbol": "TT",
    "decimals": 18,
    "blockchain": "Ethereum",
    "derivationPath": "m/44'/1001'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1Extended",
    "explorer": {
      "url": "https://scan.thundercore.com",
      "txPath": "/transactions/",
      "accountPath": "/address/"
    },
    "info": {
      "url": "https://thundercore.com",
      "source": "https://github.com/thundercore/pala",
      "rpc": "https://mainnet-rpc.thundercore.com",
      "documentation": "https://eth.wiki/json-rpc/API"
    }
  },
  {
    "id": "harmony",
    "name": "Harmony",
    "coinId": 1023,
    "symbol": "ONE",
    "decimals": 18,
    "blockchain": "Harmony",
    "derivationPath": "m/44'/1023'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1Extended",
    "hrp": "one",
    "explorer": {
      "url": "https://explorer.harmony.one",
      "txPath": "/#/tx/",
      "accountPath": "/#/address/"
    },
    "info": {
      "url": "https://harmony.one",
      "source": "https://github.com/harmony-one/go-sdk",
      "rpc": "",
      "documentation": "https://docs.harmony.one/home/harmony-networks/harmony-network-overview/mainnet"
    }
  },
  {
    "id": "oasis",
    "name": "Oasis",
    "coinId": 474,
    "symbol": "ROSE",
    "decimals": 9,
    "blockchain": "OasisNetwork",
    "derivationPath": "m/44'/474'/0'",
    "curve": "ed25519",
    "publicKeyType": "ed25519",
    "hrp": "oasis",
    "explorer": {
      "url": "https://oasisscan.com",
      "txPath": "/transactions/",
      "accountPath": "/accounts/detail/",
      "sampleTx": "0b9bd4983f1c88a1c71bf33562b6ba02b3064e01697d15a0de4bfe1922ec74b8",
      "sampleAccount": "oasis1qrx376dmwuckmruzn9vq64n49clw72lywctvxdf4"
    },
    "info": {
      "url": "https://oasisprotocol.org/",
      "source": "https://github.com/oasisprotocol/oasis-core",
      "rpc": "https://rosetta.oasis.dev/api/v1",
      "documentation": "https://docs.oasis.dev/oasis-core/"
    }
  },
  {
    "id": "ontology",
    "name": "Ontology",
    "coinId": 1024,
    "symbol": "ONT",
    "decimals": 0,
    "blockchain": "Ontology",
    "derivationPath": "m/44'/1024'/0'/0/0",
    "curve": "nist256p1",
    "publicKeyType": "nist256p1",
    "explorer": {
      "url": "https://explorer.ont.io",
      "txPath": "/transaction/",
      "accountPath": "/address/"
    },
    "info": {
      "url": "https://ont.io",
      "source": "https://github.com/ontio/ontology",
      "rpc": "http://dappnode1.ont.io:20336",
      "documentation": "https://github.com/ontio/ontology/blob/master/docs/specifications/rpc_api.md"
    }
  },
  {
    "id": "tezos",
    "name": "Tezos",
    "coinId": 1729,
    "symbol": "XTZ",
    "decimals": 6,
    "blockchain": "Tezos",
    "derivationPath": "m/44'/1729'/0'/0'",
    "curve": "ed25519",
    "publicKeyType": "ed25519",
    "explorer": {
      "url": "https://tzstats.com",
      "txPath": "/",
      "accountPath": "/"
    },
    "info": {
      "url": "https://tezos.com",
      "source": "https://gitlab.com/tezos/tezos",
      "rpc": "https://rpc.tulip.tools/mainnet",
      "documentation": "https://tezos.gitlab.io/tezos/api/rpc.html"
    }
  },
  {
    "id": "cardano",
    "name": "Cardano",
    "coinId": 1815,
    "symbol": "ADA",
    "decimals": 6,
    "blockchain": "Cardano",
    "derivationPath": "m/1852'/1815'/0'/0/0",
    "curve": "ed25519Extended",
    "publicKeyType": "ed25519Extended",
    "hrp": "addr",
    "explorer": {
      "url": "https://shelleyexplorer.cardano.org",
      "txPath": "/tx/",
      "accountPath": "/address/",
      "sampleTx": "b7a6c5cadab0f64bdc89c77ee4a351463aba5c33f2cef6bbd6542a74a90a3af3",
      "sampleAccount": "addr1s3xuxwfetyfe7q9u3rfn6je9stlvcgmj8rezd87qjjegdtxm3y3f2mgtn87mrny9r77gm09h6ecslh3gmarrvrp9n4yzmdnecfxyu59jz29g8j"
    },
    "info": {
      "url": "https://www.cardano.org",
      "source": "https://github.com/input-output-hk/cardano-sl",
      "rpc": "",
      "documentation": "https://cardanodocs.com/introduction/"
    }
  },
  {
    "id": "kin",
    "name": "Kin",
    "coinId": 2017,
    "symbol": "KIN",
    "decimals": 5,
    "blockchain": "Stellar",
    "derivationPath": "m/44'/2017'/0'",
    "curve": "ed25519",
    "publicKeyType": "ed25519",
    "explorer": {
      "url": "https://www.kin.org",
      "txPath": "/blockchainInfoPage/?&dataType=public&header=Transaction&id=",
      "accountPath": "/blockchainAccount/?&dataType=public&header=accountID&id="
    },
    "info": {
      "url": "https://www.kin.org",
      "source": "https://github.com/kinecosystem/go",
      "rpc": "https://horizon.kinfederation.com",
      "documentation": "https://www.stellar.org/developers/horizon/reference"
    },
    "deprecated": true
  },
  {
    "id": "qtum",
    "name": "Qtum",
    "coinId": 2301,
    "symbol": "QTUM",
    "decimals": 8,
    "blockchain": "Bitcoin",
    "derivationPath": "m/44'/2301'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1",
    "p2pkhPrefix": 58,
    "p2shPrefix": 50,
    "hrp": "qc",
    "publicKeyHasher": "sha256ripemd",
    "base58Hasher": "sha256d",
    "xpub": "xpub",
    "xprv": "xprv",
    "explorer": {
      "url": "https://qtum.info",
      "txPath": "/tx/",
      "accountPath": "/address/"
    },
    "info": {
      "url": "https://qtum.org",
      "source": "https://github.com/trezor/blockbook",
      "rpc": "",
      "documentation": "https://github.com/trezor/blockbook/blob/master/docs/api.md"
    }
  },
  {
    "id": "nebulas",
    "name": "Nebulas",
    "coinId": 2718,
    "symbol": "NAS",
    "decimals": 18,
    "blockchain": "Nebulas",
    "derivationPath": "m/44'/2718'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1Extended",
    "explorer": {
      "url": "https://explorer.nebulas.io",
      "txPath": "/#/tx/",
      "accountPath": "/#/address/"
    },
    "info": {
      "url": "https://nebulas.io",
      "source": "https://github.com/nebulasio/go-nebulas",
      "rpc": "https://mainnet.nebulas.io",
      "documentation": "https://wiki.nebulas.io/en/latest/dapp-development/rpc/rpc.html"
    }
  },
  {
    "id": "gochain",
    "name": "GoChain",
    "coinId": 6060,
    "symbol": "GO",
    "decimals": 18,
    "blockchain": "Ethereum",
    "derivationPath": "m/44'/6060'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1Extended",
    "explorer": {
      "url": "https://explorer.gochain.io",
      "txPath": "/tx/",
      "accountPath": "/addr/"
    },
    "info": {
      "url": "https://gochain.io",
      "source": "https://github.com/gochain-io/gochain",
      "rpc": "https://rpc.gochain.io",
      "documentation": "https://eth.wiki/json-rpc/API"
    }
  },
  {
    "id": "nuls",
    "name": "NULS",
    "coinId": 8964,
    "symbol": "NULS",
    "decimals": 8,
    "blockchain": "NULS",
    "derivationPath": "m/44'/8964'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1",
    "explorer": {
      "url": "https://nulscan.io",
      "txPath": "/transaction/info?hash=",
      "accountPath": "/address/info?address="
    },
    "info": {
      "url": "https://nuls.io",
      "source": "https://github.com/nuls-io/nuls-v2",
      "rpc": "https://public1.nuls.io/",
      "documentation": "https://docs.nuls.io/"
    }
  },
  {
    "id": "zelcash",
    "name": "Zelcash",
    "displayName": "Flux",
    "coinId": 19167,
    "symbol": "FLUX",
    "decimals": 8,
    "blockchain": "Bitcoin",
    "derivationPath": "m/44'/19167'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1",
    "staticPrefix": 28,
    "p2pkhPrefix": 184,
    "p2shPrefix": 189,
    "publicKeyHasher": "sha256ripemd",
    "base58Hasher": "sha256d",
    "xpub": "xpub",
    "xprv": "xprv",
    "explorer": {
      "url": "https://explorer.runonflux.io",
      "txPath": "/tx/",
      "accountPath": "/address/"
    },
    "info": {
      "url": "https://runonflux.io",
      "source": "https://github.com/trezor/blockbook",
      "rpc": "https://blockbook.runonflux.io",
      "documentation": "https://github.com/trezor/blockbook/blob/master/docs/api.md"
    }
  },
  {
    "id": "wanchain",
    "name": "Wanchain",
    "coinId": 5718350,
    "symbol": "WAN",
    "decimals": 18,
    "blockchain": "Ethereum",
    "derivationPath": "m/44'/5718350'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1Extended",
    "explorer": {
      "url": "https://www.wanscan.org",
      "txPath": "/tx/",
      "accountPath": "/address/",
      "sampleTx": "0x180ea96a3218b82b9b35d796823266d8a425c182507adfe5eeffc96e6a14d856",
      "sampleAccount": "0xc6D3DBf8dF90BA3f957A9634677805eee0e43bBe"
    },
    "info": {
      "url": "https://wanchain.org",
      "source": "https://github.com/wanchain/go-wanchain",
      "rpc": "",
      "documentation": "https://eth.wiki/json-rpc/API"
    }
  },
  {
    "id": "waves",
    "name": "Waves",
    "coinId": 5741564,
    "symbol": "WAVES",
    "decimals": 8,
    "blockchain": "Waves",
    "derivationPath": "m/44'/5741564'/0'/0'/0'",
    "curve": "ed25519",
    "publicKeyType": "curve25519",
    "explorer": {
      "url": "https://wavesexplorer.com",
      "txPath": "/tx/",
      "accountPath": "/address/"
    },
    "info": {
      "url": "https://wavesplatform.com",
      "source": "https://github.com/wavesplatform/Waves",
      "rpc": "https://nodes.wavesnodes.com",
      "documentation": "https://nodes.wavesnodes.com/api-docs/index.html"
    }
  },
  {
    "id": "bsc",
    "name": "Smart Chain Legacy",
    "coinId": 10000714,
    "slip44": 714,
    "symbol": "BNB",
    "decimals": 18,
    "blockchain": "Ethereum",
    "derivationPath": "m/44'/714'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1Extended",
    "explorer": {
      "url": "https://bscscan.com",
      "txPath": "/tx/",
      "accountPath": "/address/",
      "sampleTx": "0xb9ae2e808fe8e57171f303ad8f6e3fd17d949b0bfc7b4db6e8e30a71cc517d7e",
      "sampleAccount": "0x35552c16704d214347f29Fa77f77DA6d75d7C752"
    },
    "info": {
      "url": "https://www.binance.org/en/smartChain",
      "source": "https://github.com/binance-chain/bsc",
      "rpc": "https://data-seed-prebsc-1-s1.binance.org:8545",
      "documentation": "https://eth.wiki/json-rpc/API"
    },
    "deprecated": true
  },
  {
    "id": "smartchain",
    "name": "Smart Chain",
    "coinId": 20000714,
    "slip44": 714,
    "symbol": "BNB",
    "decimals": 18,
    "blockchain": "Ethereum",
    "derivationPath": "m/44'/60'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1Extended",
    "explorer": {
      "url": "https://bscscan.com",
      "txPath": "/tx/",
      "accountPath": "/address/",
      "sampleTx": "0xb9ae2e808fe8e57171f303ad8f6e3fd17d949b0bfc7b4db6e8e30a71cc517d7e",
      "sampleAccount": "0x35552c16704d214347f29Fa77f77DA6d75d7C752"
    },
    "info": {
      "url": "https://www.binance.org/en/smartChain",
      "source": "https://github.com/binance-chain/bsc",
      "rpc": "https://bsc-dataseed1.binance.org",
      "documentation": "https://eth.wiki/json-rpc/API"
    }
  },
  {
    "id": "polygon",
    "name": "Polygon",
    "coinId": 966,
    "symbol": "MATIC",
    "decimals": 18,
    "blockchain": "Ethereum",
    "derivationPath": "m/44'/60'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1Extended",
    "explorer": {
      "url": "https://polygonscan.com",
      "txPath": "/tx/",
      "accountPath": "/address/",
      "sampleTx": "0xe26ed1470d5bf99a53d687843e7acdf7e4ba6620af93b4d672e714de90476e8e",
      "sampleAccount": "0x720E1fa107A1Df39Db4E78A3633121ac36Bec132"
    },
    "info": {
      "url": "https://polygon.technology",
      "source": "https://github.com/maticnetwork/contracts",
      "rpc": "https://rpc-mainnet.matic.network",
      "documentation": "https://eth.wiki/json-rpc/API"
    }
  },
  {
    "id": "thorchain",
    "name": "THORChain",
    "coinId": 931,
    "symbol": "RUNE",
    "decimals": 8,
    "blockchain": "Cosmos",
    "derivationPath": "m/44'/931'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1",
    "hrp": "thor",
    "explorer": {
      "url": "https://viewblock.io/thorchain",
      "txPath": "/tx/",
      "accountPath": "/address/",
      "sampleTx": "ADF0899E58C177E2391F22D04E9C5E1C35BB0F75B42B363A0761687907FD9476",
      "sampleAccount": "thor196yf4pq80hjrmz7nnh0ar0ypqg02r0w4dq4mzu"
    },
    "info": {
      "url": "https://thorchain.org",
      "source": "https://gitlab.com/thorchain/thornode",
      "rpc": "https://seed.thorchain.info",
      "documentation": "https://docs.thorchain.org"
    }
  },
  {
    "id": "optimism",
    "name": "Optimism",
    "displayName": "Optimistic Ethereum",
    "coinId": 10000070,
    "slip44": 60,
    "symbol": "OETH",
    "decimals": 18,
    "blockchain": "Ethereum",
    "derivationPath": "m/44'/60'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1Extended",
    "explorer": {
      "url": "https://optimistic.etherscan.io",
      "txPath": "/tx/",
      "accountPath": "/address/"
    },
    "info": {
      "url": "https://optimism.io/",
      "source": "https://github.com/ethereum-optimism/optimism",
      "rpc": "https://mainnet.optimism.io",
      "documentation": "https://eth.wiki/json-rpc/API"
    }
  },
  {
    "id": "arbitrum",
    "name": "Arbitrum",
    "coinId": 10042221,
    "slip44": 60,
    "symbol": "ARETH",
    "decimals": 18,
    "blockchain": "Ethereum",
    "derivationPath": "m/44'/60'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1Extended",
    "explorer": {
      "url": "https://arbiscan.io",
      "txPath": "/tx/",
      "accountPath": "/address/"
    },
    "info": {
      "url": "https://arbitrum.io",
      "source": "https://github.com/OffchainLabs/arbitrum",
      "rpc": "https://node.offchainlabs.com:8547",
      "documentation": "https://developer.offchainlabs.com"
    }
  },
  {
    "id": "heco",
    "name": "ECO Chain",
    "displayName": "Huobi ECO Chain",
    "coinId": 10000553,
    "slip44": 553,
    "symbol": "HT",
    "decimals": 18,
    "blockchain": "Ethereum",
    "derivationPath": "m/44'/60'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1Extended",
    "explorer": {
      "url": "https://hecoinfo.com",
      "txPath": "/tx/",
      "accountPath": "/address/"
    },
    "info": {
      "url": "https://www.hecochain.com/en-us",
      "source": "https://github.com/HuobiGroup/huobi-eco-chain",
      "rpc": "https://http-mainnet-node.huobichain.com",
      "documentation": "https://eth.wiki/json-rpc/API"
    }
  },
  {
    "id": "avalanchec",
    "name": "Avalanche C-Chain",
    "coinId": 10009000,
    "symbol": "AVAX",
    "decimals": 18,
    "blockchain": "Ethereum",
    "derivationPath": "m/44'/60'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1Extended",
    "explorer": {
      "url": "https://cchain.explorer.avax.network",
      "txPath": "/tx/",
      "accountPath": "/address/",
      "sampleTx": "0x9243890b844219accefd8798271052f5a056453ec18984a56e81c92921330d54",
      "sampleAccount": "0xa664325f36Ec33E66323fe2620AF3f2294b2Ef3A"
    },
    "info": {
      "url": "https://www.avalabs.org/",
      "client": "https://github.com/ava-labs/avalanchego",
      "clientPublic": "https://api.avax.network/ext/bc/C/rpc",
      "clientDocs": "https://docs.avax.network/"
    }
  },
  {
    "id": "xdai",
    "name": "xDai",
    "coinId": 10000100,
    "symbol": "xDAI",
    "decimals": 18,
    "blockchain": "Ethereum",
    "derivationPath": "m/44'/60'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1Extended",
    "explorer": {
      "url": "https://blockscout.com/xdai/mainnet",
      "txPath": "/tx/",
      "accountPath": "/address/",
      "sampleTx": "0x936798a1ef607c9e856d7861b15999c770c06f0887c4fc1f6acbf3bef09899c1",
      "sampleAccount": "0x12d61a95CF55e18D267C2F1AA67d8e42ae1368f8"
    },
    "info": {
      "url": "https://www.xdaichain.com",
      "client": "https://github.com/openethereum/openethereum",
      "clientPublic": "https://rpc.xdaichain.com",
      "clientDocs": "https://eth.wiki/json-rpc/API"
    }
  },
  {
    "id": "fantom",
    "name": "Fantom",
    "coinId": 10000250,
    "symbol": "FTM",
    "decimals": 18,
    "blockchain": "Ethereum",
    "derivationPath": "m/44'/60'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1Extended",
    "explorer": {
      "url": "https://ftmscan.com",
      "txPath": "/tx/",
      "accountPath": "/address/",
      "sampleTx": "0xb0a741d882291951de1fac72e90b9baf886ddb0c9c87658a0c206490dfaa5202",
      "sampleAccount": "0x9474feb9917b87da6f0d830ba66ee0035835c0d3"
    },
    "info": {
      "url": "https://fantom.foundation",
      "client": "https://github.com/openethereum/openethereum",
      "clientPublic": "https://rpc.ftm.tools",
      "clientDocs": "https://eth.wiki/json-rpc/API"
    }
  },
  {
    "id": "cryptoorg",
    "name": "CryptoOrg",
    "displayName": "Crypto.org",
    "coinId": 394,
    "symbol": "CRO",
    "decimals": 8,
    "blockchain": "Cosmos",
    "derivationPath": "m/44'/394'/0'/0/0",
    "curve": "secp256k1",
    "publicKeyType": "secp256k1",
    "hrp": "cro",
    "explorer": {
      "url": "https://crypto.org/explorer",
      "txPath": "/tx/",
      "accountPath": "/account/",
      "sampleTx": "D87D2EB46B21466886EE149C1DEA3AE6C2E019C7D8C24FA1533A95439DDCE1E2",
      "sampleAccount": "cro10wrflcdc4pys9vvgqm98yg7yv5ltj7d3xehent"
    },
    "info": {
      "url": "https://crypto.org/",
      "client": "https://github.com/crypto-org-chain/chain-main",
      "clientPublic": "https://mainnet.crypto.org:1317/",
      "clientDocs": "https://crypto.org/docs/resources/chain-integration.html#api-documentation"
    }
  }
]
